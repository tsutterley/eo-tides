{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#eo-tides-tide-modelling-tools-for-large-scale-satellite-earth-observation-analysis","title":"<code>eo-tides</code>: Tide modelling tools for large-scale satellite Earth observation analysis","text":"<p><code>eo-tides</code> provides provides powerful parallelized tools for integrating satellite Earth observation data with tide modelling. \ud83d\udee0\ufe0f\ud83c\udf0a\ud83d\udef0\ufe0f</p> <p><code>eo-tides</code> combines advanced tide modelling functionality from the <code>pyTMD</code> package with <code>pandas</code>, <code>xarray</code> and <code>odc-geo</code>, providing a suite of flexible tools for efficient analysis of coastal and ocean Earth observation data \u2013 from regional, continental, to global scale.</p> <p>These tools can be applied to petabytes of freely available satellite data (e.g. from Digital Earth Australia or Microsoft Planetary Computer) loaded via Open Data Cube's <code>odc-stac</code> or <code>datacube</code> packages, supporting coastal and ocean earth observation analysis for any time period or location globally.</p> <p></p>"},{"location":"#highlights","title":"Highlights","text":"<ul> <li>\ud83c\udf0a Model tide heights and phases (e.g. high, low, ebb, flow) from multiple global ocean tide models in parallel, and return a <code>pandas.DataFrame</code> for further analysis</li> <li>\ud83d\udef0\ufe0f \"Tag\" satellite data with tide heights based on the exact moment of image acquisition</li> <li>\ud83c\udf10 Model tides for every individual satellite pixel through time, producing three-dimensional \"tide height\" <code>xarray</code>-format datacubes that can be integrated with satellite data</li> <li>\ud83d\udcc8 Calculate statistics describing local tide dynamics, as well as biases caused by interactions between tidal processes and satellite orbits</li> <li>\ud83d\udee0\ufe0f Validate modelled tides using measured sea levels from coastal tide gauges (e.g. GESLA Global Extreme Sea Level Analysis)</li> </ul>"},{"location":"#supported-tide-models","title":"Supported tide models","text":"<p><code>eo-tides</code> supports all ocean tide models supported by <code>pyTMD</code>. These include:</p> <ul> <li>Empirical Ocean Tide model (EOT20)</li> <li>Finite Element Solution tide models (FES2022, FES2014, FES2012)</li> <li>TOPEX/POSEIDON global tide models (TPXO10, TPXO9, TPXO8)</li> <li>Global Ocean Tide models (GOT5.6, GOT5.5, GOT4.10, GOT4.8, GOT4.7)</li> <li>Hamburg direct data Assimilation Methods for Tides models (HAMTIDE11)</li> </ul> <p>For instructions on how to set up these models for use in <code>eo-tides</code>, refer to Setting up tide models.</p>"},{"location":"#citing-eo-tides","title":"Citing <code>eo-tides</code>","text":"<p>To cite <code>eo-tides</code> in your work, please use the following citation:</p> <pre><code>Bishop-Taylor, R., Sagar, S., Phillips, C., &amp; Newey, V. (2024). eo-tides: Tide modelling tools for large-scale satellite earth observation analysis. https://github.com/GeoscienceAustralia/eo-tides\n</code></pre> <p>In addition, please consider also citing the underlying <code>pyTMD</code> Python package which powers the tide modelling functionality behind <code>eo-tides</code>:</p> <pre><code>Sutterley, T. C., Alley, K., Brunt, K., Howard, S., Padman, L., Siegfried, M. (2017) pyTMD: Python-based tidal prediction software. 10.5281/zenodo.5555395\n</code></pre>"},{"location":"#next-steps","title":"Next steps","text":"<p>To get started, first follow the guide to installing <code>eo-tides</code>, and then set up one or multiple global ocean tide models. </p>"},{"location":"api/","title":"API reference","text":""},{"location":"api/#eo_tides.model","title":"eo_tides.model","text":"<p>Functions:</p> Name Description <code>ensemble_tides</code> <p>Combine multiple tide models into a single locally optimised</p> <code>model_phases</code> <p>Model tide phases (low-flow, high-flow, high-ebb, low-ebb)</p> <code>model_tides</code> <p>Model tide heights at multiple coordinates and/or timesteps</p>"},{"location":"api/#eo_tides.model.ensemble_tides","title":"ensemble_tides","text":"<pre><code>ensemble_tides(\n    tide_df,\n    crs,\n    ensemble_models,\n    ensemble_func=None,\n    ensemble_top_n=3,\n    ranking_points=\"https://dea-public-data-dev.s3-ap-southeast-2.amazonaws.com/derivative/dea_intertidal/supplementary/rankings_ensemble_2017-2019.fgb\",\n    ranking_valid_perc=0.02,\n    **idw_kwargs\n)\n</code></pre> <p>Combine multiple tide models into a single locally optimised ensemble tide model using external model ranking data (e.g. satellite altimetry or NDWI-tide correlations along the coastline) to inform the selection of the best local models.</p> <p>This function performs the following steps:</p> <ol> <li>Takes a dataframe of tide heights from multiple tide models, as    produced by <code>eo_tides.model.model_tides</code></li> <li>Loads model ranking points from an external file, filters them    based on the valid data percentage, and retains relevant columns</li> <li>Interpolates the model rankings into the coordinates of the    original dataframe using Inverse Weighted Interpolation (IDW)</li> <li>Uses rankings to combine multiple tide models into a single    optimised ensemble model (by default, by taking the mean of the    top 3 ranked models)</li> <li>Returns a new dataframe with the combined ensemble model predictions</li> </ol> <p>Parameters:</p> Name Type Description Default <code>DataFrame</code> <p>DataFrame produced by <code>eo_tides.model.model_tides</code>, containing tide model predictions in long format with columns: <code>[\"time\", \"x\", \"y\", \"tide_height\", \"tide_model\"]</code>.</p> required <code>string</code> <p>Coordinate reference system for the \"x\" and \"y\" coordinates in <code>tide_df</code>. Used to ensure that interpolations are performed in the correct CRS.</p> required <code>list</code> <p>A list of models to include in the ensemble modelling process. All values must exist as columns with the prefix \"rank_\" in <code>ranking_points</code>.</p> required <code>dict</code> <p>By default, a simple ensemble model will be calculated by taking the mean of the <code>ensemble_top_n</code> tide models at each location. However, a dictionary containing more complex ensemble calculations can also be provided. Dictionary keys are used to name output ensemble models; functions should take a column named \"rank\" and convert it to a weighting, e.g.: <code>ensemble_func = {\"ensemble-custom\": lambda x: x[\"rank\"] &lt;= 3}</code></p> <code>None</code> <code>int</code> <p>If <code>ensemble_func</code> is None, this sets the number of top models to include in the mean ensemble calculation. Defaults to 3.</p> <code>3</code> <code>str</code> <p>Path to the file containing model ranking points. This dataset should include columns containing rankings for each tide model, named with the prefix \"rank_\". e.g. \"rank_EOT20\". Low values should represent high rankings (e.g. 1 = top ranked). The default value points to an example file covering Australia.</p> <code>'https://dea-public-data-dev.s3-ap-southeast-2.amazonaws.com/derivative/dea_intertidal/supplementary/rankings_ensemble_2017-2019.fgb'</code> <code>float</code> <p>Minimum percentage of valid data required to include a model rank point in the analysis, as defined in a column named \"valid_perc\". Defaults to 0.02.</p> <code>0.02</code> <p>Optional keyword arguments to pass to the <code>idw</code> function used for interpolation. Useful values include <code>k</code> (number of nearest neighbours to use in interpolation), <code>max_dist</code> (maximum distance to nearest neighbours), and <code>k_min</code> (minimum number of neighbours required after <code>max_dist</code> is applied).</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing the ensemble model predictions, matching the format of the input <code>tide_df</code> (e.g. columns <code>[\"time\", \"x\", \"y\", \"tide_height\", \"tide_model\"]</code>. By default the 'tide_model' column will be labeled \"ensemble\" for the combined model predictions (but if a custom dictionary of ensemble functions is provided via <code>ensemble_func</code>, each ensemble will be named using the provided dictionary keys).</p> Source code in <code>eo_tides/model.py</code> <pre><code>def ensemble_tides(\n    tide_df,\n    crs,\n    ensemble_models,\n    ensemble_func=None,\n    ensemble_top_n=3,\n    ranking_points=\"https://dea-public-data-dev.s3-ap-southeast-2.amazonaws.com/derivative/dea_intertidal/supplementary/rankings_ensemble_2017-2019.fgb\",\n    ranking_valid_perc=0.02,\n    **idw_kwargs,\n):\n    \"\"\"Combine multiple tide models into a single locally optimised\n    ensemble tide model using external model ranking data (e.g.\n    satellite altimetry or NDWI-tide correlations along the coastline)\n    to inform the selection of the best local models.\n\n    This function performs the following steps:\n\n    1. Takes a dataframe of tide heights from multiple tide models, as\n       produced by `eo_tides.model.model_tides`\n    2. Loads model ranking points from an external file, filters them\n       based on the valid data percentage, and retains relevant columns\n    3. Interpolates the model rankings into the coordinates of the\n       original dataframe using Inverse Weighted Interpolation (IDW)\n    4. Uses rankings to combine multiple tide models into a single\n       optimised ensemble model (by default, by taking the mean of the\n       top 3 ranked models)\n    5. Returns a new dataframe with the combined ensemble model predictions\n\n    Parameters\n    ----------\n    tide_df : pandas.DataFrame\n        DataFrame produced by `eo_tides.model.model_tides`, containing\n        tide model predictions in long format with columns:\n        `[\"time\", \"x\", \"y\", \"tide_height\", \"tide_model\"]`.\n    crs : string\n        Coordinate reference system for the \"x\" and \"y\" coordinates in\n        `tide_df`. Used to ensure that interpolations are performed\n        in the correct CRS.\n    ensemble_models : list\n        A list of models to include in the ensemble modelling process.\n        All values must exist as columns with the prefix \"rank_\" in\n        `ranking_points`.\n    ensemble_func : dict, optional\n        By default, a simple ensemble model will be calculated by taking\n        the mean of the `ensemble_top_n` tide models at each location.\n        However, a dictionary containing more complex ensemble\n        calculations can also be provided. Dictionary keys are used\n        to name output ensemble models; functions should take a column\n        named \"rank\" and convert it to a weighting, e.g.:\n        `ensemble_func = {\"ensemble-custom\": lambda x: x[\"rank\"] &lt;= 3}`\n    ensemble_top_n : int, optional\n        If `ensemble_func` is None, this sets the number of top models\n        to include in the mean ensemble calculation. Defaults to 3.\n    ranking_points : str, optional\n        Path to the file containing model ranking points. This dataset\n        should include columns containing rankings for each tide\n        model, named with the prefix \"rank_\". e.g. \"rank_EOT20\".\n        Low values should represent high rankings (e.g. 1 = top ranked).\n        The default value points to an example file covering Australia.\n    ranking_valid_perc : float, optional\n        Minimum percentage of valid data required to include a model\n        rank point in the analysis, as defined in a column named\n        \"valid_perc\". Defaults to 0.02.\n    **idw_kwargs\n        Optional keyword arguments to pass to the `idw` function used\n        for interpolation. Useful values include `k` (number of nearest\n        neighbours to use in interpolation), `max_dist` (maximum\n        distance to nearest neighbours), and `k_min` (minimum number of\n        neighbours required after `max_dist` is applied).\n\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame containing the ensemble model predictions, matching\n        the format of the input `tide_df` (e.g. columns `[\"time\", \"x\",\n        \"y\", \"tide_height\", \"tide_model\"]`. By default the 'tide_model'\n        column will be labeled \"ensemble\" for the combined model\n        predictions (but if a custom dictionary of ensemble functions is\n        provided via `ensemble_func`, each ensemble will be named using\n        the provided dictionary keys).\n\n    \"\"\"\n    # Raise data if `tide_df` provided in wide format\n    if \"tide_model\" not in tide_df:\n        raise Exception(\n            \"`tide_df` does not contain the expected 'tide_model' and \"\n            \"'tide_height' columns. Ensure that tides were modelled in \"\n            \"long format (i.e. `output_format='long'` in `model_tides`).\"\n        )\n\n    # Extract x and y coords from dataframe\n    x = tide_df.index.get_level_values(level=\"x\")\n    y = tide_df.index.get_level_values(level=\"y\")\n\n    # Load model ranks points and reproject to same CRS as x and y\n    model_ranking_cols = [f\"rank_{m}\" for m in ensemble_models]\n    try:\n        model_ranks_gdf = (\n            gpd.read_file(ranking_points, engine=\"pyogrio\")\n            .to_crs(crs)\n            .query(f\"valid_perc &gt; {ranking_valid_perc}\")\n            .dropna(how=\"all\")[model_ranking_cols + [\"geometry\"]]\n        )\n    except KeyError:\n        error_msg = f\"\"\"\n        Not all of the expected \"rank_\" columns {model_ranking_cols} were\n        found in the columns of the ranking points file ({ranking_points}).\n        Consider passing a custom list of models using `ensemble_models`.\n        \"\"\"\n        raise Exception(textwrap.dedent(error_msg).strip()) from None\n\n    # Use points to interpolate model rankings into requested x and y\n    id_kwargs_str = \"\" if idw_kwargs == {} else idw_kwargs\n    print(f\"Interpolating model rankings using IDW interpolation {id_kwargs_str}\")\n    ensemble_ranks_df = (\n        # Run IDW interpolation on subset of ranking columns\n        pd.DataFrame(\n            idw(\n                input_z=model_ranks_gdf[model_ranking_cols],\n                input_x=model_ranks_gdf.geometry.x,\n                input_y=model_ranks_gdf.geometry.y,\n                output_x=x,\n                output_y=y,\n                **idw_kwargs,\n            ),\n            columns=model_ranking_cols,\n        )\n        .assign(x=x, y=y)\n        # Drop any duplicates then melt columns into long format\n        .drop_duplicates()\n        .melt(id_vars=[\"x\", \"y\"], var_name=\"tide_model\", value_name=\"rank\")\n        # Remore \"rank_\" prefix to get plain model names\n        .replace({\"^rank_\": \"\"}, regex=True)\n        # Set index columns and rank across groups\n        .set_index([\"tide_model\", \"x\", \"y\"])\n        .groupby([\"x\", \"y\"])\n        .rank()\n    )\n\n    # If no custom ensemble funcs are provided, use a default ensemble\n    # calculation that takes the mean of the top N tide models\n    if ensemble_func is None:\n        ensemble_func = {\"ensemble\": lambda x: x[\"rank\"] &lt;= ensemble_top_n}\n\n    # Create output list to hold computed ensemble model outputs\n    ensemble_list = []\n\n    # Loop through all provided ensemble generation functions\n    for ensemble_n, ensemble_f in ensemble_func.items():\n        print(f\"Combining models into single {ensemble_n} model\")\n\n        # Join ranks to input tide data, compute weightings and group\n        grouped = (\n            # Add tide model as an index so we can join with model ranks\n            tide_df.set_index(\"tide_model\", append=True)\n            .join(ensemble_ranks_df)\n            # Add temp columns containing weightings and weighted values\n            .assign(\n                weights=ensemble_f,  # use custom func to compute weights\n                weighted=lambda i: i.tide_height * i.weights,\n            )\n            # Groupby is specified in a weird order here as this seems\n            # to be the easiest way to preserve correct index sorting\n            .groupby([\"x\", \"y\", \"time\"])\n        )\n\n        # Use weightings to combine multiple models into single ensemble\n        ensemble_df = (\n            # Calculate weighted mean and convert back to dataframe\n            grouped.weighted.sum()\n            .div(grouped.weights.sum())\n            .to_frame(\"tide_height\")\n            # Label ensemble model and ensure indexes are in expected order\n            .assign(tide_model=ensemble_n)\n            .reorder_levels([\"time\", \"x\", \"y\"], axis=0)\n        )\n\n        ensemble_list.append(ensemble_df)\n\n    # Combine all ensemble models and return as a single dataframe\n    return pd.concat(ensemble_list)\n</code></pre>"},{"location":"api/#eo_tides.model.ensemble_tides(tide_df)","title":"<code>tide_df</code>","text":""},{"location":"api/#eo_tides.model.ensemble_tides(crs)","title":"<code>crs</code>","text":""},{"location":"api/#eo_tides.model.ensemble_tides(ensemble_models)","title":"<code>ensemble_models</code>","text":""},{"location":"api/#eo_tides.model.ensemble_tides(ensemble_func)","title":"<code>ensemble_func</code>","text":""},{"location":"api/#eo_tides.model.ensemble_tides(ensemble_top_n)","title":"<code>ensemble_top_n</code>","text":""},{"location":"api/#eo_tides.model.ensemble_tides(ranking_points)","title":"<code>ranking_points</code>","text":""},{"location":"api/#eo_tides.model.ensemble_tides(ranking_valid_perc)","title":"<code>ranking_valid_perc</code>","text":""},{"location":"api/#eo_tides.model.ensemble_tides(**idw_kwargs)","title":"<code>**idw_kwargs</code>","text":""},{"location":"api/#eo_tides.model.model_phases","title":"model_phases","text":"<pre><code>model_phases(\n    x,\n    y,\n    time,\n    model=\"EOT20\",\n    directory=None,\n    time_offset=\"15 min\",\n    return_tides=False,\n    **model_tides_kwargs\n)\n</code></pre> <p>Model tide phases (low-flow, high-flow, high-ebb, low-ebb) at multiple coordinates and/or timesteps using using one or more ocean tide models.</p> <p>Ebb and low phases are calculated by running the <code>eo_tides.model.model_tides</code> function twice, once for the requested timesteps, and again after subtracting a small time offset (by default, 15 minutes). If tides increased over this period, they are assigned as \"flow\"; if they decreased, they are assigned as \"ebb\". Tides are considered \"high\" if equal or greater than 0 metres tide height, otherwise \"low\".</p> <p>This function supports all parameters that are supported by <code>model_tides</code>.</p> <p>Parameters:</p> Name Type Description Default <code>float or list of float</code> <p>One or more x and y coordinates used to define the location at which to model tide phases. By default these coordinates should be lat/lon; use \"crs\" if they are in a custom coordinate reference system.</p> required <code>float or list of float</code> <p>One or more x and y coordinates used to define the location at which to model tide phases. By default these coordinates should be lat/lon; use \"crs\" if they are in a custom coordinate reference system.</p> required <code>DatetimeLike</code> <p>Times at which to model tide phases (in UTC). Accepts any format that can be converted by <code>pandas.to_datetime()</code>; e.g. np.ndarray[datetime64], pd.DatetimeIndex, pd.Timestamp, datetime.datetime and strings (e.g. \"2020-01-01 23:00\"). For example: <code>time=pd.date_range(start=\"2000\", end=\"2001\", freq=\"5h\")</code></p> required <code>str or list of str</code> <p>The tide model (or list of models) to use to model tides. Defaults to \"EOT20\"; specify \"all\" to use all models available in <code>directory</code>. For a full list of available and supported models, run <code>eo_tides.utils.list_models</code>.</p> <code>'EOT20'</code> <code>str</code> <p>The directory containing tide model data files. If no path is provided, this will default to the environment variable <code>EO_TIDES_TIDE_MODELS</code> if set, or raise an error if not. Tide modelling files should be stored in sub-folders for each model that match the structure required by <code>pyTMD</code> (https://geoscienceaustralia.github.io/eo-tides/setup/).</p> <code>None</code> <code>str</code> <p>The time offset/delta used to generate a time series of offset tide heights required for phase calculation. Defeaults to \"15 min\"; can be any string passed to <code>pandas.Timedelta</code>.</p> <code>'15 min'</code> <code>bool</code> <p>Whether to return intermediate modelled tide heights as a \"tide_height\" column in the output dataframe. Defaults to False.</p> <code>False</code> <p>Optional parameters passed to the <code>eo_tides.model.model_tides</code> function. Important parameters include <code>output_format</code> (e.g. whether to return results in wide or long format), <code>crop</code> (whether to crop tide model constituent files on-the-fly to improve performance) etc.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A dataframe containing modelled tide phases.</p> Source code in <code>eo_tides/model.py</code> <pre><code>def model_phases(\n    x: float | list[float] | xr.DataArray,\n    y: float | list[float] | xr.DataArray,\n    time: DatetimeLike,\n    model: str | list[str] = \"EOT20\",\n    directory: str | os.PathLike | None = None,\n    time_offset: str = \"15 min\",\n    return_tides: bool = False,\n    **model_tides_kwargs,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Model tide phases (low-flow, high-flow, high-ebb, low-ebb)\n    at multiple coordinates and/or timesteps using using one\n    or more ocean tide models.\n\n    Ebb and low phases are calculated by running the\n    `eo_tides.model.model_tides` function twice, once for\n    the requested timesteps, and again after subtracting a\n    small time offset (by default, 15 minutes). If tides\n    increased over this period, they are assigned as \"flow\";\n    if they decreased, they are assigned as \"ebb\".\n    Tides are considered \"high\" if equal or greater than 0\n    metres tide height, otherwise \"low\".\n\n    This function supports all parameters that are supported\n    by `model_tides`.\n\n    Parameters\n    ----------\n    x, y : float or list of float\n        One or more x and y coordinates used to define\n        the location at which to model tide phases. By default\n        these coordinates should be lat/lon; use \"crs\" if they\n        are in a custom coordinate reference system.\n    time : DatetimeLike\n        Times at which to model tide phases (in UTC). Accepts\n        any format that can be converted by `pandas.to_datetime()`;\n        e.g. np.ndarray[datetime64], pd.DatetimeIndex, pd.Timestamp,\n        datetime.datetime and strings (e.g. \"2020-01-01 23:00\").\n        For example: `time=pd.date_range(start=\"2000\", end=\"2001\", freq=\"5h\")`\n    model : str or list of str, optional\n        The tide model (or list of models) to use to model tides.\n        Defaults to \"EOT20\"; specify \"all\" to use all models available\n        in `directory`. For a full list of available and supported models,\n        run `eo_tides.utils.list_models`.\n    directory : str, optional\n        The directory containing tide model data files. If no path is\n        provided, this will default to the environment variable\n        `EO_TIDES_TIDE_MODELS` if set, or raise an error if not.\n        Tide modelling files should be stored in sub-folders for each\n        model that match the structure required by `pyTMD`\n        (&lt;https://geoscienceaustralia.github.io/eo-tides/setup/&gt;).\n    time_offset: str, optional\n        The time offset/delta used to generate a time series of\n        offset tide heights required for phase calculation. Defeaults\n        to \"15 min\"; can be any string passed to `pandas.Timedelta`.\n    return_tides: bool, optional\n        Whether to return intermediate modelled tide heights as a\n        \"tide_height\" column in the output dataframe. Defaults to False.\n    **model_tides_kwargs :\n        Optional parameters passed to the `eo_tides.model.model_tides`\n        function. Important parameters include `output_format` (e.g.\n        whether to return results in wide or long format), `crop`\n        (whether to crop tide model constituent files on-the-fly to\n        improve performance) etc.\n\n    Returns\n    -------\n    pandas.DataFrame\n        A dataframe containing modelled tide phases.\n\n    \"\"\"\n\n    # Pop output format and mode for special handling\n    output_format = model_tides_kwargs.pop(\"output_format\", \"long\")\n    mode = model_tides_kwargs.pop(\"mode\", \"one-to-many\")\n\n    # Model tides\n    tide_df = model_tides(\n        x=x,\n        y=y,\n        time=time,\n        model=model,\n        directory=directory,\n        **model_tides_kwargs,\n    )\n\n    # Model tides for a time 15 minutes prior to each previously\n    # modelled satellite acquisition time. This allows us to compare\n    # tide heights to see if they are rising or falling.\n    pre_df = model_tides(\n        x=x,\n        y=y,\n        time=time - pd.Timedelta(time_offset),\n        model=model,\n        directory=directory,\n        **model_tides_kwargs,\n    )\n\n    # Compare tides computed for each timestep. If the previous tide\n    # was higher than the current tide, the tide is 'ebbing'. If the\n    # previous tide was lower, the tide is 'flowing'\n    ebb_flow = (tide_df.tide_height &lt; pre_df.tide_height.values).replace({True: \"ebb\", False: \"flow\"})\n\n    # If tides are greater than 0, then \"high\", otherwise \"low\"\n    high_low = (tide_df.tide_height &gt;= 0).replace({True: \"high\", False: \"low\"})\n\n    # Combine into one string and add to data\n    tide_df[\"tide_phase\"] = high_low.astype(str) + \"-\" + ebb_flow.astype(str)\n\n    # Optionally convert to a wide format dataframe with a tide model in\n    # each dataframe column\n    if output_format == \"wide\":\n        # Pivot into wide format with each time model as a column\n        print(\"Converting to a wide format dataframe\")\n        tide_df = tide_df.pivot(columns=\"tide_model\")\n\n        # If in 'one-to-one' mode, reindex using our input time/x/y\n        # values to ensure the output is sorted the same as our inputs\n        if mode == \"one-to-one\":\n            output_indices = pd.MultiIndex.from_arrays([time, x, y], names=[\"time\", \"x\", \"y\"])\n            tide_df = tide_df.reindex(output_indices)\n\n        # Optionally drop tides\n        if not return_tides:\n            return tide_df.drop(\"tide_height\", axis=1)[\"tide_phase\"]\n\n    # Optionally drop tide heights\n    if not return_tides:\n        return tide_df.drop(\"tide_height\", axis=1)\n\n    return tide_df\n</code></pre>"},{"location":"api/#eo_tides.model.model_phases(x)","title":"<code>x</code>","text":""},{"location":"api/#eo_tides.model.model_phases(y)","title":"<code>y</code>","text":""},{"location":"api/#eo_tides.model.model_phases(time)","title":"<code>time</code>","text":""},{"location":"api/#eo_tides.model.model_phases(model)","title":"<code>model</code>","text":""},{"location":"api/#eo_tides.model.model_phases(directory)","title":"<code>directory</code>","text":""},{"location":"api/#eo_tides.model.model_phases(time_offset)","title":"<code>time_offset</code>","text":""},{"location":"api/#eo_tides.model.model_phases(return_tides)","title":"<code>return_tides</code>","text":""},{"location":"api/#eo_tides.model.model_phases(**model_tides_kwargs)","title":"<code>**model_tides_kwargs</code>","text":""},{"location":"api/#eo_tides.model.model_tides","title":"model_tides","text":"<pre><code>model_tides(\n    x,\n    y,\n    time,\n    model=\"EOT20\",\n    directory=None,\n    crs=\"EPSG:4326\",\n    mode=\"one-to-many\",\n    output_format=\"long\",\n    output_units=\"m\",\n    method=\"linear\",\n    extrapolate=True,\n    cutoff=None,\n    crop=True,\n    crop_buffer=5,\n    parallel=True,\n    parallel_splits=\"auto\",\n    parallel_max=None,\n    ensemble_models=None,\n    **ensemble_kwargs\n)\n</code></pre> <p>Model tide heights at multiple coordinates and/or timesteps using using one or more ocean tide models.</p> <p>This function is parallelised to improve performance, and supports all tidal models supported by <code>pyTMD</code>, including:</p> <ul> <li>Empirical Ocean Tide model (EOT20)</li> <li>Finite Element Solution tide models (FES2022, FES2014, FES2012)</li> <li>TOPEX/POSEIDON global tide models (TPXO10, TPXO9, TPXO8)</li> <li>Global Ocean Tide models (GOT5.6, GOT5.5, GOT4.10, GOT4.8, GOT4.7)</li> <li>Hamburg direct data Assimilation Methods for Tides models (HAMTIDE11)</li> </ul> <p>This function requires access to tide model data files. These should be placed in a folder with subfolders matching the structure required by <code>pyTMD</code>. For more details: https://geoscienceaustralia.github.io/eo-tides/setup/ https://pytmd.readthedocs.io/en/latest/getting_started/Getting-Started.html#directories</p> <p>This function is a modification of the <code>pyTMD</code> package's <code>pyTMD.compute.tide_elevations</code> function. For more info: https://pytmd.readthedocs.io/en/latest/api_reference/compute.html#pyTMD.compute.tide_elevations</p> <p>Parameters:</p> Name Type Description Default <code>float or list of float</code> <p>One or more x and y coordinates used to define the location at which to model tides. By default these coordinates should be lat/lon; use \"crs\" if they are in a custom coordinate reference system.</p> required <code>float or list of float</code> <p>One or more x and y coordinates used to define the location at which to model tides. By default these coordinates should be lat/lon; use \"crs\" if they are in a custom coordinate reference system.</p> required <code>DatetimeLike</code> <p>Times at which to model tide heights (in UTC). Accepts any format that can be converted by <code>pandas.to_datetime()</code>; e.g. np.ndarray[datetime64], pd.DatetimeIndex, pd.Timestamp, datetime.datetime and strings (e.g. \"2020-01-01 23:00\"). For example: <code>time=pd.date_range(start=\"2000\", end=\"2001\", freq=\"5h\")</code></p> required <code>str or list of str</code> <p>The tide model (or list of models) to use to model tides. Defaults to \"EOT20\"; specify \"all\" to use all models available in <code>directory</code>. For a full list of available and supported models, run <code>eo_tides.utils.list_models</code>.</p> <code>'EOT20'</code> <code>str</code> <p>The directory containing tide model data files. If no path is provided, this will default to the environment variable <code>EO_TIDES_TIDE_MODELS</code> if set, or raise an error if not. Tide modelling files should be stored in sub-folders for each model that match the structure required by <code>pyTMD</code> (https://geoscienceaustralia.github.io/eo-tides/setup/).</p> <code>None</code> <code>str</code> <p>Input coordinate reference system for x and y coordinates. Defaults to \"EPSG:4326\" (WGS84; degrees latitude, longitude).</p> <code>'EPSG:4326'</code> <code>str</code> <p>The analysis mode to use for tide modelling. Supports two options:</p> <ul> <li>\"one-to-many\": Models tides for every timestep in \"time\" at every input x and y coordinate point. This is useful if you want to model tides for a specific list of timesteps across multiple spatial points (e.g. for the same set of satellite acquisition times at various locations across your study area).</li> <li>\"one-to-one\": Model tides using a unique timestep for each set of x and y coordinates. In this mode, the number of x and y points must equal the number of timesteps provided in \"time\".</li> </ul> <code>'one-to-many'</code> <code>str</code> <p>Whether to return the output dataframe in long format (with results stacked vertically along \"tide_model\" and \"tide_height\" columns), or wide format (with a column for each tide model). Defaults to \"long\".</p> <code>'long'</code> <code>str</code> <p>Whether to return modelled tides in floating point metre units, or integer centimetre units (i.e. scaled by 100) or integer millimetre units (i.e. scaled by 1000. Returning outputs in integer units can be useful for reducing memory usage. Defaults to \"m\" for metres; set to \"cm\" for centimetres or \"mm\" for millimetres.</p> <code>'m'</code> <code>str</code> <p>Method used to interpolate tidal constituents from model files. Defaults to \"linear\"; options include:</p> <ul> <li>\"linear\", \"nearest\": scipy regular grid interpolations</li> <li>\"spline\": scipy bivariate spline interpolation</li> <li>\"bilinear\": quick bilinear interpolation</li> </ul> <code>'linear'</code> <code>bool</code> <p>Whether to extrapolate tides into x and y coordinates outside of the valid tide modelling domain using nearest-neighbor.</p> <code>True</code> <code>float</code> <p>Extrapolation cutoff in kilometers. The default is None, which will extrapolate for all points regardless of distance from the valid tide modelling domain.</p> <code>None</code> <code>bool</code> <p>Whether to crop tide model constituent files on-the-fly to improve performance. Defaults to True; use <code>crop_buffer</code> to customise the buffer distance used to crop the files.</p> <code>True</code> <code>int or float</code> <p>The buffer distance in degrees used to crop tide model constituent files around the modelling area. Defaults to 5, which will crop constituents using a five degree buffer on either side of the analysis extent.</p> <code>5</code> <code>bool</code> <p>Whether to parallelise tide modelling. If multiple tide models are requested, these will be run in parallel using <code>concurrent.futures</code>. If enough workers are available, the analysis will also be split into spatial chunks for additional parallelisation (see \"parallel_splits\" below). Default is True.</p> <code>True</code> <code>str or int</code> <p>Whether to split the input x and y coordinates into smaller, evenly-sized chunks that are processed in parallel. This can provide a large performance boost when processing large numbers of coordinates. The default is \"auto\", which will automatically attempt to determine optimal splits based on available CPUs, the number of input points, and the number of models.</p> <code>'auto'</code> <code>int</code> <p>Maximum number of processes to run in parallel. The default of None will automatically determine this from your available CPUs.</p> <code>None</code> <code>list of str</code> <p>An optional list of models used to generate the ensemble tide model if \"ensemble\" tide modelling is requested. Defaults to <code>[\"EOT20\", \"FES2012\", \"FES2014_extrapolated\", \"FES2022_extrapolated\", \"GOT4.10\", \"GOT5.5_extrapolated\", \"GOT5.6_extrapolated\", \"TPXO10-atlas-v2-nc\", \"TPXO8-atlas-nc\", \"TPXO9-atlas-v5-nc\"]</code>.</p> <code>None</code> <p>Keyword arguments used to customise the generation of optional ensemble tide models if \"ensemble\" modelling are requested. These are passed to the underlying <code>_ensemble_model</code> function. Useful parameters include <code>ranking_points</code> (path to model rankings data), <code>k</code> (for controlling how model rankings are interpolated), and <code>ensemble_top_n</code> (how many top models to use in the ensemble calculation).</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A dataframe containing modelled tide heights.</p> Source code in <code>eo_tides/model.py</code> <pre><code>def model_tides(\n    x: float | list[float] | xr.DataArray,\n    y: float | list[float] | xr.DataArray,\n    time: DatetimeLike,\n    model: str | list[str] = \"EOT20\",\n    directory: str | os.PathLike | None = None,\n    crs: str = \"EPSG:4326\",\n    mode: str = \"one-to-many\",\n    output_format: str = \"long\",\n    output_units: str = \"m\",\n    method: str = \"linear\",\n    extrapolate: bool = True,\n    cutoff: float | None = None,\n    crop: bool = True,\n    crop_buffer: float | None = 5,\n    parallel: bool = True,\n    parallel_splits: int | str = \"auto\",\n    parallel_max: int | None = None,\n    ensemble_models: list[str] | None = None,\n    **ensemble_kwargs,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Model tide heights at multiple coordinates and/or timesteps\n    using using one or more ocean tide models.\n\n    This function is parallelised to improve performance, and\n    supports all tidal models supported by `pyTMD`, including:\n\n    - Empirical Ocean Tide model (EOT20)\n    - Finite Element Solution tide models (FES2022, FES2014, FES2012)\n    - TOPEX/POSEIDON global tide models (TPXO10, TPXO9, TPXO8)\n    - Global Ocean Tide models (GOT5.6, GOT5.5, GOT4.10, GOT4.8, GOT4.7)\n    - Hamburg direct data Assimilation Methods for Tides models (HAMTIDE11)\n\n    This function requires access to tide model data files.\n    These should be placed in a folder with subfolders matching\n    the structure required by `pyTMD`. For more details:\n    &lt;https://geoscienceaustralia.github.io/eo-tides/setup/&gt;\n    &lt;https://pytmd.readthedocs.io/en/latest/getting_started/Getting-Started.html#directories&gt;\n\n    This function is a modification of the `pyTMD` package's\n    `pyTMD.compute.tide_elevations` function. For more info:\n    &lt;https://pytmd.readthedocs.io/en/latest/api_reference/compute.html#pyTMD.compute.tide_elevations&gt;\n\n    Parameters\n    ----------\n    x, y : float or list of float\n        One or more x and y coordinates used to define\n        the location at which to model tides. By default these\n        coordinates should be lat/lon; use \"crs\" if they\n        are in a custom coordinate reference system.\n    time : DatetimeLike\n        Times at which to model tide heights (in UTC). Accepts\n        any format that can be converted by `pandas.to_datetime()`;\n        e.g. np.ndarray[datetime64], pd.DatetimeIndex, pd.Timestamp,\n        datetime.datetime and strings (e.g. \"2020-01-01 23:00\").\n        For example: `time=pd.date_range(start=\"2000\", end=\"2001\", freq=\"5h\")`\n    model : str or list of str, optional\n        The tide model (or list of models) to use to model tides.\n        Defaults to \"EOT20\"; specify \"all\" to use all models available\n        in `directory`. For a full list of available and supported models,\n        run `eo_tides.utils.list_models`.\n    directory : str, optional\n        The directory containing tide model data files. If no path is\n        provided, this will default to the environment variable\n        `EO_TIDES_TIDE_MODELS` if set, or raise an error if not.\n        Tide modelling files should be stored in sub-folders for each\n        model that match the structure required by `pyTMD`\n        (&lt;https://geoscienceaustralia.github.io/eo-tides/setup/&gt;).\n    crs : str, optional\n        Input coordinate reference system for x and y coordinates.\n        Defaults to \"EPSG:4326\" (WGS84; degrees latitude, longitude).\n    mode : str, optional\n        The analysis mode to use for tide modelling. Supports two options:\n\n        - \"one-to-many\": Models tides for every timestep in \"time\" at\n        every input x and y coordinate point. This is useful if you\n        want to model tides for a specific list of timesteps across\n        multiple spatial points (e.g. for the same set of satellite\n        acquisition times at various locations across your study area).\n        - \"one-to-one\": Model tides using a unique timestep for each\n        set of x and y coordinates. In this mode, the number of x and\n        y points must equal the number of timesteps provided in \"time\".\n    output_format : str, optional\n        Whether to return the output dataframe in long format (with\n        results stacked vertically along \"tide_model\" and \"tide_height\"\n        columns), or wide format (with a column for each tide model).\n        Defaults to \"long\".\n    output_units : str, optional\n        Whether to return modelled tides in floating point metre units,\n        or integer centimetre units (i.e. scaled by 100) or integer\n        millimetre units (i.e. scaled by 1000. Returning outputs in\n        integer units can be useful for reducing memory usage.\n        Defaults to \"m\" for metres; set to \"cm\" for centimetres or \"mm\"\n        for millimetres.\n    method : str, optional\n        Method used to interpolate tidal constituents\n        from model files. Defaults to \"linear\"; options include:\n\n        - \"linear\", \"nearest\": scipy regular grid interpolations\n        - \"spline\": scipy bivariate spline interpolation\n        - \"bilinear\": quick bilinear interpolation\n    extrapolate : bool, optional\n        Whether to extrapolate tides into x and y coordinates outside of\n        the valid tide modelling domain using nearest-neighbor.\n    cutoff : float, optional\n        Extrapolation cutoff in kilometers. The default is None, which\n        will extrapolate for all points regardless of distance from the\n        valid tide modelling domain.\n    crop : bool, optional\n        Whether to crop tide model constituent files on-the-fly to\n        improve performance. Defaults to True; use `crop_buffer`\n        to customise the buffer distance used to crop the files.\n    crop_buffer : int or float, optional\n        The buffer distance in degrees used to crop tide model\n        constituent files around the modelling area. Defaults to 5,\n        which will crop constituents using a five degree buffer on either\n        side of the analysis extent.\n    parallel : bool, optional\n        Whether to parallelise tide modelling. If multiple tide models are\n        requested, these will be run in parallel using `concurrent.futures`.\n        If enough workers are available, the analysis will also be split\n        into spatial chunks for additional parallelisation (see \"parallel_splits\"\n        below). Default is True.\n    parallel_splits : str or int, optional\n        Whether to split the input x and y coordinates into smaller,\n        evenly-sized chunks that are processed in parallel. This can\n        provide a large performance boost when processing large numbers\n        of coordinates. The default is \"auto\", which will automatically\n        attempt to determine optimal splits based on available CPUs,\n        the number of input points, and the number of models.\n    parallel_max : int, optional\n        Maximum number of processes to run in parallel. The default of\n        None will automatically determine this from your available CPUs.\n    ensemble_models : list of str, optional\n        An optional list of models used to generate the ensemble tide\n        model if \"ensemble\" tide modelling is requested. Defaults to\n        `[\"EOT20\", \"FES2012\", \"FES2014_extrapolated\", \"FES2022_extrapolated\",\n        \"GOT4.10\", \"GOT5.5_extrapolated\", \"GOT5.6_extrapolated\",\n        \"TPXO10-atlas-v2-nc\", \"TPXO8-atlas-nc\", \"TPXO9-atlas-v5-nc\"]`.\n    **ensemble_kwargs :\n        Keyword arguments used to customise the generation of optional\n        ensemble tide models if \"ensemble\" modelling are requested.\n        These are passed to the underlying `_ensemble_model` function.\n        Useful parameters include `ranking_points` (path to model\n        rankings data), `k` (for controlling how model rankings are\n        interpolated), and `ensemble_top_n` (how many top models to use\n        in the ensemble calculation).\n\n    Returns\n    -------\n    pandas.DataFrame\n        A dataframe containing modelled tide heights.\n\n    \"\"\"\n    # Turn inputs into arrays for consistent handling\n    x = np.atleast_1d(x)\n    y = np.atleast_1d(y)\n    time = _standardise_time(time)\n\n    # Validate input arguments\n    assert time is not None, \"Times for modelling tides must be provided via `time`.\"\n    assert method in (\"bilinear\", \"spline\", \"linear\", \"nearest\")\n    assert output_units in (\n        \"m\",\n        \"cm\",\n        \"mm\",\n    ), \"Output units must be either 'm', 'cm', or 'mm'.\"\n    assert output_format in (\n        \"long\",\n        \"wide\",\n    ), \"Output format must be either 'long' or 'wide'.\"\n    assert np.issubdtype(x.dtype, np.number), \"`x` must contain only valid numeric values, and must not be None.\"\n    assert np.issubdtype(y.dtype, np.number), \"`y` must contain only valid numeric values, and must not be None..\"\n    assert len(x) == len(y), \"x and y must be the same length.\"\n    if mode == \"one-to-one\":\n        assert len(x) == len(time), (\n            \"The number of supplied x and y points and times must be \"\n            \"identical in 'one-to-one' mode. Use 'one-to-many' mode if \"\n            \"you intended to model multiple timesteps at each point.\"\n        )\n\n    # Set tide modelling files directory. If no custom path is\n    # provided, try global environment variable.\n    directory = _set_directory(directory)\n\n    # Standardise model list, handling \"all\" and \"ensemble\" functionality\n    models_to_process, models_requested, ensemble_models = _standardise_models(\n        model=model,\n        directory=directory,\n        ensemble_models=ensemble_models,\n    )\n\n    # Update tide modelling func to add default keyword arguments that\n    # are used for every iteration during parallel processing\n    iter_func = partial(\n        _model_tides,\n        directory=directory,\n        crs=crs,\n        mode=mode,\n        output_units=output_units,\n        method=method,\n        extrapolate=extrapolate,\n        cutoff=np.inf if cutoff is None else cutoff,\n        crop=crop,\n        crop_buffer=crop_buffer,\n    )\n\n    # If automatic parallel splits, calculate optimal value\n    # based on available parallelisation, number of points\n    # and number of models\n    if parallel_splits == \"auto\":\n        parallel_splits = _parallel_splits(\n            total_points=len(x),\n            model_count=len(models_to_process),\n            parallel_max=parallel_max,\n        )\n\n    # Verify that parallel splits are not larger than number of points\n    assert isinstance(parallel_splits, int)\n    if parallel_splits &gt; len(x):\n        raise ValueError(f\"Parallel splits ({parallel_splits}) cannot be larger than the number of points ({len(x)}).\")\n\n    # Parallelise if either multiple models or multiple splits requested\n    if parallel &amp; ((len(models_to_process) &gt; 1) | (parallel_splits &gt; 1)):\n        with ProcessPoolExecutor(max_workers=parallel_max) as executor:\n            print(\n                f\"Modelling tides with {', '.join(models_to_process)} in parallel (models: {len(models_to_process)}, splits: {parallel_splits})\"\n            )\n\n            # Optionally split lon/lat points into `splits_n` chunks\n            # that will be applied in parallel\n            x_split = np.array_split(x, parallel_splits)\n            y_split = np.array_split(y, parallel_splits)\n\n            # Get every combination of models and lat/lon points, and\n            # extract as iterables that can be passed to `executor.map()`\n            # In \"one-to-many\" mode, pass entire set of timesteps to each\n            # parallel iteration by repeating timesteps by number of total\n            # parallel iterations. In \"one-to-one\" mode, split up\n            # timesteps into smaller parallel chunks too.\n            if mode == \"one-to-many\":\n                model_iters, x_iters, y_iters = zip(\n                    *[(m, x_split[i], y_split[i]) for m in models_to_process for i in range(parallel_splits)],\n                )\n                time_iters = [time] * len(model_iters)\n            elif mode == \"one-to-one\":\n                time_split = np.array_split(time, parallel_splits)\n                model_iters, x_iters, y_iters, time_iters = zip(\n                    *[\n                        (m, x_split[i], y_split[i], time_split[i])\n                        for m in models_to_process\n                        for i in range(parallel_splits)\n                    ],\n                )\n\n            # Apply func in parallel, iterating through each input param\n            try:\n                model_outputs = list(\n                    tqdm(\n                        executor.map(iter_func, model_iters, x_iters, y_iters, time_iters),\n                        total=len(model_iters),\n                    ),\n                )\n            except BrokenProcessPool:\n                error_msg = (\n                    \"Parallelised tide modelling failed, likely to to an out-of-memory error. \"\n                    \"Try reducing the size of your analysis, or set `parallel=False`.\"\n                )\n                raise RuntimeError(error_msg)\n\n    # Model tides in series if parallelisation is off\n    else:\n        model_outputs = []\n\n        for model_i in models_to_process:\n            print(f\"Modelling tides with {model_i}\")\n            tide_df = iter_func(model_i, x, y, time)\n            model_outputs.append(tide_df)\n\n    # Combine outputs into a single dataframe\n    tide_df = pd.concat(model_outputs, axis=0)\n\n    # Optionally compute ensemble model and add to dataframe\n    if \"ensemble\" in models_requested:\n        ensemble_df = ensemble_tides(tide_df, crs, ensemble_models, **ensemble_kwargs)\n\n        # Update requested models with any custom ensemble models, then\n        # filter the dataframe to keep only models originally requested\n        models_requested = list(np.union1d(models_requested, ensemble_df.tide_model.unique()))\n        tide_df = pd.concat([tide_df, ensemble_df]).query(\"tide_model in @models_requested\")\n\n    # Optionally convert to a wide format dataframe with a tide model in\n    # each dataframe column\n    if output_format == \"wide\":\n        # Pivot into wide format with each time model as a column\n        print(\"Converting to a wide format dataframe\")\n        tide_df = tide_df.pivot(columns=\"tide_model\", values=\"tide_height\")\n\n        # If in 'one-to-one' mode, reindex using our input time/x/y\n        # values to ensure the output is sorted the same as our inputs\n        if mode == \"one-to-one\":\n            output_indices = pd.MultiIndex.from_arrays([time, x, y], names=[\"time\", \"x\", \"y\"])\n            tide_df = tide_df.reindex(output_indices)\n\n    return tide_df\n</code></pre>"},{"location":"api/#eo_tides.model.model_tides(x)","title":"<code>x</code>","text":""},{"location":"api/#eo_tides.model.model_tides(y)","title":"<code>y</code>","text":""},{"location":"api/#eo_tides.model.model_tides(time)","title":"<code>time</code>","text":""},{"location":"api/#eo_tides.model.model_tides(model)","title":"<code>model</code>","text":""},{"location":"api/#eo_tides.model.model_tides(directory)","title":"<code>directory</code>","text":""},{"location":"api/#eo_tides.model.model_tides(crs)","title":"<code>crs</code>","text":""},{"location":"api/#eo_tides.model.model_tides(mode)","title":"<code>mode</code>","text":""},{"location":"api/#eo_tides.model.model_tides(output_format)","title":"<code>output_format</code>","text":""},{"location":"api/#eo_tides.model.model_tides(output_units)","title":"<code>output_units</code>","text":""},{"location":"api/#eo_tides.model.model_tides(method)","title":"<code>method</code>","text":""},{"location":"api/#eo_tides.model.model_tides(extrapolate)","title":"<code>extrapolate</code>","text":""},{"location":"api/#eo_tides.model.model_tides(cutoff)","title":"<code>cutoff</code>","text":""},{"location":"api/#eo_tides.model.model_tides(crop)","title":"<code>crop</code>","text":""},{"location":"api/#eo_tides.model.model_tides(crop_buffer)","title":"<code>crop_buffer</code>","text":""},{"location":"api/#eo_tides.model.model_tides(parallel)","title":"<code>parallel</code>","text":""},{"location":"api/#eo_tides.model.model_tides(parallel_splits)","title":"<code>parallel_splits</code>","text":""},{"location":"api/#eo_tides.model.model_tides(parallel_max)","title":"<code>parallel_max</code>","text":""},{"location":"api/#eo_tides.model.model_tides(ensemble_models)","title":"<code>ensemble_models</code>","text":""},{"location":"api/#eo_tides.model.model_tides(**ensemble_kwargs)","title":"<code>**ensemble_kwargs</code>","text":""},{"location":"api/#eo_tides.eo","title":"eo_tides.eo","text":"<p>Functions:</p> Name Description <code>pixel_tides</code> <p>Model tide heights for every pixel in a multi-dimensional</p> <code>tag_tides</code> <p>Model tide heights for every timestep in a multi-dimensional</p>"},{"location":"api/#eo_tides.eo.pixel_tides","title":"pixel_tides","text":"<pre><code>pixel_tides(\n    data,\n    time=None,\n    model=\"EOT20\",\n    directory=None,\n    resample=True,\n    calculate_quantiles=None,\n    resolution=None,\n    buffer=None,\n    resample_method=\"bilinear\",\n    dask_chunks=None,\n    dask_compute=True,\n    **model_tides_kwargs\n)\n</code></pre> <p>Model tide heights for every pixel in a multi-dimensional dataset, using one or more ocean tide models.</p> <p>This function models tides into a low-resolution tide modelling grid covering the spatial extent of the input data (buffered to reduce potential edge effects). These modelled tides can then be resampled back into the original higher resolution dataset's extent and resolution to produce a modelled tide height for every pixel through time.</p> <p>This function uses the parallelised <code>model_tides</code> function under the hood. It supports all tidal models supported by <code>pyTMD</code>, including:</p> <ul> <li>Empirical Ocean Tide model (EOT20)</li> <li>Finite Element Solution tide models (FES2022, FES2014, FES2012)</li> <li>TOPEX/POSEIDON global tide models (TPXO10, TPXO9, TPXO8)</li> <li>Global Ocean Tide models (GOT5.6, GOT5.5, GOT4.10, GOT4.8, GOT4.7)</li> <li>Hamburg direct data Assimilation Methods for Tides models (HAMTIDE11)</li> </ul> <p>This function requires access to tide model data files. These should be placed in a folder with subfolders matching the structure required by <code>pyTMD</code>. For more details: https://geoscienceaustralia.github.io/eo-tides/setup/ https://pytmd.readthedocs.io/en/latest/getting_started/Getting-Started.html#directories</p> <p>Parameters:</p> Name Type Description Default <code>Dataset or DataArray or GeoBox</code> <p>A multi-dimensional dataset or GeoBox pixel grid that will be used to define the spatial tide modelling grid. If <code>data</code> is an xarray object, it should include a \"time\" dimension. If no \"time\" dimension exists or if <code>data</code> is a GeoBox, then times must be passed using the <code>time</code> parameter.</p> required <code>DatetimeLike</code> <p>By default, tides will be modelled using times from the \"time\" dimension of <code>data</code>. Alternatively, this param can be used to provide a custom set of times. Accepts any format that can be converted by <code>pandas.to_datetime()</code>. For example: <code>time=pd.date_range(start=\"2000\", end=\"2001\", freq=\"5h\")</code></p> <code>None</code> <code>str or list of str</code> <p>The tide model (or list of models) to use to model tides. If a list is provided, a new \"tide_model\" dimension will be added to the <code>xarray.DataArray</code> outputs. Defaults to \"EOT20\"; specify \"all\" to use all models available in <code>directory</code>. For a full list of available and supported models, run <code>eo_tides.utils.list_models</code>.</p> <code>'EOT20'</code> <code>str</code> <p>The directory containing tide model data files. If no path is provided, this will default to the environment variable <code>EO_TIDES_TIDE_MODELS</code> if set, or raise an error if not. Tide modelling files should be stored in sub-folders for each model that match the structure required by <code>pyTMD</code> (https://geoscienceaustralia.github.io/eo-tides/setup/).</p> <code>None</code> <code>bool</code> <p>Whether to resample low resolution tides back into <code>data</code>'s original higher resolution grid. Set this to <code>False</code> if you do not want low resolution tides to be re-projected back to higher resolution.</p> <code>True</code> <code>tuple of float or numpy.ndarray</code> <p>Rather than returning all individual tides, low-resolution tides can be first aggregated using a quantile calculation by passing in a tuple or array of quantiles to compute. For example, this could be used to calculate the min/max tide across all times: <code>calculate_quantiles=(0.0, 1.0)</code>.</p> <code>None</code> <code>float</code> <p>The desired resolution of the low-resolution grid used for tide modelling. The default None will create a 5000 m resolution grid if <code>data</code> has a projected CRS (i.e. metre units), or a 0.05 degree resolution grid if <code>data</code> has a geographic CRS (e.g. degree units). Note: higher resolutions do not necessarily provide better tide modelling performance, as results will be limited by the resolution of the underlying global tide model (e.g. 1/16th degree / ~5 km resolution grid for FES2014).</p> <code>None</code> <code>float</code> <p>The amount by which to buffer the higher resolution grid extent when creating the new low resolution grid. This buffering ensures that modelled tides are seamless across analysis boundaries. This buffer is eventually be clipped away when the low-resolution modelled tides are re-projected back to the original resolution and extent of <code>data</code>. To ensure that at least two low-resolution grid pixels occur outside of the dataset bounds, the default None applies a 12000 m buffer if <code>data</code> has a projected CRS (i.e. metre units), or a 0.12 degree buffer if <code>data</code> has a geographic CRS (e.g. degree units).</p> <code>None</code> <code>str</code> <p>If resampling is requested (see <code>resample</code> above), use this resampling method when resampling from low resolution to high resolution pixels. Defaults to \"bilinear\"; valid options include \"nearest\", \"cubic\", \"min\", \"max\", \"average\" etc.</p> <code>'bilinear'</code> <code>tuple of float</code> <p>Can be used to configure custom Dask chunking for the final resampling step. By default, chunks will be automatically set to match y/x chunks from <code>data</code> if they exist; otherwise chunks will be chosen to cover the entire y/x extent of the dataset. For custom chunks, provide a tuple in the form <code>(y, x)</code>, e.g. <code>(2048, 2048)</code>.</p> <code>None</code> <code>bool</code> <p>Whether to compute results of the resampling step using Dask. If False, <code>tides_highres</code> will be returned as a Dask-enabled array.</p> <code>True</code> <p>Optional parameters passed to the <code>eo_tides.model.model_tides</code> function. Important parameters include <code>cutoff</code> (used to extrapolate modelled tides away from the coast; defaults to <code>np.inf</code>), <code>crop</code> (whether to crop tide model constituent files on-the-fly to improve performance) etc.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>tides_da</code> <code>DataArray</code> <p>A three-dimensional tide height array. If <code>resample=True</code> (default), a high-resolution array of tide heights will be returned that matches the exact spatial resolution and extents of <code>data</code>. This will contain either tide heights for every timestep in <code>data</code> (or in <code>times</code> if provided), or tide height quantiles for every quantile provided by <code>calculate_quantiles</code>. If <code>resample=False</code>, results for the intermediate low-resolution tide modelling grid will be returned instead.</p> Source code in <code>eo_tides/eo.py</code> <pre><code>def pixel_tides(\n    data: xr.Dataset | xr.DataArray | GeoBox,\n    time: DatetimeLike | None = None,\n    model: str | list[str] = \"EOT20\",\n    directory: str | os.PathLike | None = None,\n    resample: bool = True,\n    calculate_quantiles: np.ndarray | tuple[float, float] | None = None,\n    resolution: float | None = None,\n    buffer: float | None = None,\n    resample_method: str = \"bilinear\",\n    dask_chunks: tuple[float, float] | None = None,\n    dask_compute: bool = True,\n    **model_tides_kwargs,\n) -&gt; xr.DataArray:\n    \"\"\"\n    Model tide heights for every pixel in a multi-dimensional\n    dataset, using one or more ocean tide models.\n\n    This function models tides into a low-resolution tide\n    modelling grid covering the spatial extent of the input\n    data (buffered to reduce potential edge effects). These\n    modelled tides can then be resampled back into the original\n    higher resolution dataset's extent and resolution to\n    produce a modelled tide height for every pixel through time.\n\n    This function uses the parallelised `model_tides` function\n    under the hood. It supports all tidal models supported by\n    `pyTMD`, including:\n\n    - Empirical Ocean Tide model (EOT20)\n    - Finite Element Solution tide models (FES2022, FES2014, FES2012)\n    - TOPEX/POSEIDON global tide models (TPXO10, TPXO9, TPXO8)\n    - Global Ocean Tide models (GOT5.6, GOT5.5, GOT4.10, GOT4.8, GOT4.7)\n    - Hamburg direct data Assimilation Methods for Tides models (HAMTIDE11)\n\n    This function requires access to tide model data files.\n    These should be placed in a folder with subfolders matching\n    the structure required by `pyTMD`. For more details:\n    &lt;https://geoscienceaustralia.github.io/eo-tides/setup/&gt;\n    &lt;https://pytmd.readthedocs.io/en/latest/getting_started/Getting-Started.html#directories&gt;\n\n    Parameters\n    ----------\n    data : xarray.Dataset or xarray.DataArray or odc.geo.geobox.GeoBox\n        A multi-dimensional dataset or GeoBox pixel grid that will\n        be used to define the spatial tide modelling grid. If `data`\n        is an xarray object, it should include a \"time\" dimension.\n        If no \"time\" dimension exists or if `data` is a GeoBox,\n        then times must be passed using the `time` parameter.\n    time : DatetimeLike, optional\n        By default, tides will be modelled using times from the\n        \"time\" dimension of `data`. Alternatively, this param can\n        be used to provide a custom set of times. Accepts any format\n        that can be converted by `pandas.to_datetime()`. For example:\n        `time=pd.date_range(start=\"2000\", end=\"2001\", freq=\"5h\")`\n    model : str or list of str, optional\n        The tide model (or list of models) to use to model tides.\n        If a list is provided, a new \"tide_model\" dimension will be\n        added to the `xarray.DataArray` outputs. Defaults to \"EOT20\";\n        specify \"all\" to use all models available in `directory`.\n        For a full list of available and supported models, run\n        `eo_tides.utils.list_models`.\n    directory : str, optional\n        The directory containing tide model data files. If no path is\n        provided, this will default to the environment variable\n        `EO_TIDES_TIDE_MODELS` if set, or raise an error if not.\n        Tide modelling files should be stored in sub-folders for each\n        model that match the structure required by `pyTMD`\n        (&lt;https://geoscienceaustralia.github.io/eo-tides/setup/&gt;).\n    resample : bool, optional\n        Whether to resample low resolution tides back into `data`'s original\n        higher resolution grid. Set this to `False` if you do not want\n        low resolution tides to be re-projected back to higher resolution.\n    calculate_quantiles : tuple of float or numpy.ndarray, optional\n        Rather than returning all individual tides, low-resolution tides\n        can be first aggregated using a quantile calculation by passing in\n        a tuple or array of quantiles to compute. For example, this could\n        be used to calculate the min/max tide across all times:\n        `calculate_quantiles=(0.0, 1.0)`.\n    resolution : float, optional\n        The desired resolution of the low-resolution grid used for tide\n        modelling. The default None will create a 5000 m resolution grid\n        if `data` has a projected CRS (i.e. metre units), or a 0.05 degree\n        resolution grid if `data` has a geographic CRS (e.g. degree units).\n        Note: higher resolutions do not necessarily provide better\n        tide modelling performance, as results will be limited by the\n        resolution of the underlying global tide model (e.g. 1/16th\n        degree / ~5 km resolution grid for FES2014).\n    buffer : float, optional\n        The amount by which to buffer the higher resolution grid extent\n        when creating the new low resolution grid. This buffering\n        ensures that modelled tides are seamless across analysis\n        boundaries. This buffer is eventually be clipped away when\n        the low-resolution modelled tides are re-projected back to the\n        original resolution and extent of `data`. To ensure that at least\n        two low-resolution grid pixels occur outside of the dataset\n        bounds, the default None applies a 12000 m buffer if `data` has a\n        projected CRS (i.e. metre units), or a 0.12 degree buffer if\n        `data` has a geographic CRS (e.g. degree units).\n    resample_method : str, optional\n        If resampling is requested (see `resample` above), use this\n        resampling method when resampling from low resolution to high\n        resolution pixels. Defaults to \"bilinear\"; valid options include\n        \"nearest\", \"cubic\", \"min\", \"max\", \"average\" etc.\n    dask_chunks : tuple of float, optional\n        Can be used to configure custom Dask chunking for the final\n        resampling step. By default, chunks will be automatically set\n        to match y/x chunks from `data` if they exist; otherwise chunks\n        will be chosen to cover the entire y/x extent of the dataset.\n        For custom chunks, provide a tuple in the form `(y, x)`, e.g.\n        `(2048, 2048)`.\n    dask_compute : bool, optional\n        Whether to compute results of the resampling step using Dask.\n        If False, `tides_highres` will be returned as a Dask-enabled array.\n    **model_tides_kwargs :\n        Optional parameters passed to the `eo_tides.model.model_tides`\n        function. Important parameters include `cutoff` (used to\n        extrapolate modelled tides away from the coast; defaults to\n        `np.inf`), `crop` (whether to crop tide model constituent files\n        on-the-fly to improve performance) etc.\n    Returns\n    -------\n    tides_da : xr.DataArray\n        A three-dimensional tide height array.\n        If `resample=True` (default), a high-resolution array of tide\n        heights will be returned that matches the exact spatial resolution\n        and extents of `data`. This will contain either tide heights for\n        every timestep in `data` (or in `times` if provided), or tide height\n        quantiles for every quantile provided by `calculate_quantiles`.\n        If `resample=False`, results for the intermediate low-resolution\n        tide modelling grid will be returned instead.\n    \"\"\"\n    # Standardise data inputs, time and models\n    gbox, time_coords = _standardise_inputs(data, time)\n    dask_chunks = _resample_chunks(data, dask_chunks)\n    model = [model] if isinstance(model, str) else model\n\n    # Determine spatial dimensions\n    y_dim, x_dim = gbox.dimensions\n\n    # Determine resolution and buffer, using different defaults for\n    # geographic (i.e. degrees) and projected (i.e. metres) CRSs:\n    assert gbox.crs is not None\n    crs_units = gbox.crs.units[0][0:6]\n    if gbox.crs.geographic:\n        if resolution is None:\n            resolution = 0.05\n        elif resolution &gt; 360:\n            raise ValueError(\n                f\"A resolution of greater than 360 was \"\n                f\"provided, but `data` has a geographic CRS \"\n                f\"in {crs_units} units. Did you accidently \"\n                f\"provide a resolution in projected \"\n                f\"(i.e. metre) units?\",\n            )\n        if buffer is None:\n            buffer = 0.12\n    else:\n        if resolution is None:\n            resolution = 5000\n        elif resolution &lt; 1:\n            raise ValueError(\n                f\"A resolution of less than 1 was provided, \"\n                f\"but `data` has a projected CRS in \"\n                f\"{crs_units} units. Did you accidently \"\n                f\"provide a resolution in geographic \"\n                f\"(degree) units?\",\n            )\n        if buffer is None:\n            buffer = 12000\n\n    # Raise error if resolution is less than dataset resolution\n    dataset_res = gbox.resolution.x\n    if resolution &lt; dataset_res:\n        raise ValueError(\n            f\"The resolution of the low-resolution tide \"\n            f\"modelling grid ({resolution:.2f}) is less \"\n            f\"than `data`'s pixel resolution ({dataset_res:.2f}). \"\n            f\"This can cause extremely slow tide modelling \"\n            f\"performance. Please select provide a resolution \"\n            f\"greater than {dataset_res:.2f} using \"\n            f\"`pixel_tides`'s 'resolution' parameter.\",\n        )\n\n    # Create a new reduced resolution tide modelling grid after\n    # first buffering the grid\n    print(f\"Creating reduced resolution {resolution} x {resolution} {crs_units} tide modelling array\")\n    buffered_geobox = gbox.buffered(buffer)\n    rescaled_geobox = GeoBox.from_bbox(bbox=buffered_geobox.boundingbox, resolution=resolution)\n    rescaled_ds = odc.geo.xr.xr_zeros(rescaled_geobox)\n\n    # Flatten grid to 1D, then add time dimension\n    flattened_ds = rescaled_ds.stack(z=(x_dim, y_dim))\n    flattened_ds = flattened_ds.expand_dims(dim={\"time\": time_coords})\n\n    # Model tides in parallel, returning a pandas.DataFrame\n    tide_df = model_tides(\n        x=flattened_ds[x_dim],\n        y=flattened_ds[y_dim],\n        time=flattened_ds.time,\n        crs=f\"EPSG:{gbox.crs.epsg}\",\n        model=model,\n        directory=directory,\n        **model_tides_kwargs,\n    )\n\n    # Convert our pandas.DataFrame tide modelling outputs to xarray\n    tides_lowres = (\n        # Rename x and y dataframe indexes to match x and y xarray dims\n        tide_df.rename_axis([\"time\", x_dim, y_dim])\n        # Add tide model column to dataframe indexes so we can convert\n        # our dataframe to a multidimensional xarray\n        .set_index(\"tide_model\", append=True)\n        # Convert to xarray and select our tide modelling xr.DataArray\n        .to_xarray()\n        .tide_height\n        # Re-index and transpose into our input coordinates and dim order\n        .reindex_like(rescaled_ds)\n        .transpose(\"tide_model\", \"time\", y_dim, x_dim)\n    )\n\n    # Optionally calculate and return quantiles rather than raw data.\n    # Set dtype to dtype of the input data as quantile always returns\n    # float64 (memory intensive)\n    if calculate_quantiles is not None:\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\")\n            print(\"Computing tide quantiles\")\n            tides_lowres = tides_lowres.quantile(q=calculate_quantiles, dim=\"time\").astype(tides_lowres.dtype)\n\n    # If only one tidal model exists, squeeze out \"tide_model\" dim\n    if len(tides_lowres.tide_model) == 1:\n        tides_lowres = tides_lowres.squeeze(\"tide_model\")\n\n    # Ensure CRS is present before we apply any resampling\n    tides_lowres = tides_lowres.odc.assign_crs(gbox.crs)\n\n    # Reproject into original high resolution grid\n    if resample:\n        print(\"Reprojecting tides into original resolution\")\n        tides_highres = _pixel_tides_resample(\n            tides_lowres,\n            gbox,\n            resample_method,\n            dask_chunks,\n            dask_compute,\n        )\n        return tides_highres\n\n    print(\"Returning low resolution tide array\")\n    return tides_lowres\n</code></pre>"},{"location":"api/#eo_tides.eo.pixel_tides(data)","title":"<code>data</code>","text":""},{"location":"api/#eo_tides.eo.pixel_tides(time)","title":"<code>time</code>","text":""},{"location":"api/#eo_tides.eo.pixel_tides(model)","title":"<code>model</code>","text":""},{"location":"api/#eo_tides.eo.pixel_tides(directory)","title":"<code>directory</code>","text":""},{"location":"api/#eo_tides.eo.pixel_tides(resample)","title":"<code>resample</code>","text":""},{"location":"api/#eo_tides.eo.pixel_tides(calculate_quantiles)","title":"<code>calculate_quantiles</code>","text":""},{"location":"api/#eo_tides.eo.pixel_tides(resolution)","title":"<code>resolution</code>","text":""},{"location":"api/#eo_tides.eo.pixel_tides(buffer)","title":"<code>buffer</code>","text":""},{"location":"api/#eo_tides.eo.pixel_tides(resample_method)","title":"<code>resample_method</code>","text":""},{"location":"api/#eo_tides.eo.pixel_tides(dask_chunks)","title":"<code>dask_chunks</code>","text":""},{"location":"api/#eo_tides.eo.pixel_tides(dask_compute)","title":"<code>dask_compute</code>","text":""},{"location":"api/#eo_tides.eo.pixel_tides(**model_tides_kwargs)","title":"<code>**model_tides_kwargs</code>","text":""},{"location":"api/#eo_tides.eo.tag_tides","title":"tag_tides","text":"<pre><code>tag_tides(\n    data,\n    time=None,\n    model=\"EOT20\",\n    directory=None,\n    tidepost_lat=None,\n    tidepost_lon=None,\n    **model_tides_kwargs\n)\n</code></pre> <p>Model tide heights for every timestep in a multi-dimensional dataset, and return a new <code>tide_height</code> array that can be used to \"tag\" each observation with tide heights.</p> <p>The function models tides at the centroid of the dataset by default, but a custom tidal modelling location can be specified using <code>tidepost_lat</code> and <code>tidepost_lon</code>.</p> <p>This function uses the parallelised <code>model_tides</code> function under the hood. It supports all tidal models supported by <code>pyTMD</code>, including:</p> <ul> <li>Empirical Ocean Tide model (EOT20)</li> <li>Finite Element Solution tide models (FES2022, FES2014, FES2012)</li> <li>TOPEX/POSEIDON global tide models (TPXO10, TPXO9, TPXO8)</li> <li>Global Ocean Tide models (GOT5.6, GOT5.5, GOT4.10, GOT4.8, GOT4.7)</li> <li>Hamburg direct data Assimilation Methods for Tides models (HAMTIDE11)</li> </ul> <p>Parameters:</p> Name Type Description Default <code>Dataset or DataArray or GeoBox</code> <p>A multi-dimensional dataset or GeoBox pixel grid that will be used to define the tide modelling location. If <code>data</code> is an xarray object, it should include a \"time\" dimension. If no \"time\" dimension exists or if <code>data</code> is a GeoBox, then times must be passed using the <code>time</code> parameter.</p> required <code>DatetimeLike</code> <p>By default, tides will be modelled using times from the \"time\" dimension of <code>data</code>. Alternatively, this param can be used to provide a custom set of times. Accepts any format that can be converted by <code>pandas.to_datetime()</code>. For example: <code>time=pd.date_range(start=\"2000\", end=\"2001\", freq=\"5h\")</code></p> <code>None</code> <code>str or list of str</code> <p>The tide model (or list of models) to use to model tides. If a list is provided, a new \"tide_model\" dimension will be added to the <code>xarray.DataArray</code> outputs. Defaults to \"EOT20\"; specify \"all\" to use all models available in <code>directory</code>. For a full list of available and supported models, run <code>eo_tides.utils.list_models</code>.</p> <code>'EOT20'</code> <code>str</code> <p>The directory containing tide model data files. If no path is provided, this will default to the environment variable <code>EO_TIDES_TIDE_MODELS</code> if set, or raise an error if not. Tide modelling files should be stored in sub-folders for each model that match the structure required by <code>pyTMD</code> (https://geoscienceaustralia.github.io/eo-tides/setup/).</p> <code>None</code> <code>float</code> <p>Optional coordinates used to model tides. The default is None, which uses the centroid of the dataset as the tide modelling location.</p> <code>None</code> <code>float</code> <p>Optional coordinates used to model tides. The default is None, which uses the centroid of the dataset as the tide modelling location.</p> <code>None</code> <p>Optional parameters passed to the <code>eo_tides.model.model_tides</code> function. Important parameters include <code>cutoff</code> (used to extrapolate modelled tides away from the coast; defaults to <code>np.inf</code>), <code>crop</code> (whether to crop tide model constituent files on-the-fly to improve performance) etc.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>tides_da</code> <code>DataArray</code> <p>A one-dimensional tide height array. This will contain either tide heights for every timestep in <code>data</code>, or for every time in <code>times</code> if provided.</p> Source code in <code>eo_tides/eo.py</code> <pre><code>def tag_tides(\n    data: xr.Dataset | xr.DataArray | GeoBox,\n    time: DatetimeLike | None = None,\n    model: str | list[str] = \"EOT20\",\n    directory: str | os.PathLike | None = None,\n    tidepost_lat: float | None = None,\n    tidepost_lon: float | None = None,\n    **model_tides_kwargs,\n) -&gt; xr.DataArray:\n    \"\"\"\n    Model tide heights for every timestep in a multi-dimensional\n    dataset, and return a new `tide_height` array that can\n    be used to \"tag\" each observation with tide heights.\n\n    The function models tides at the centroid of the dataset\n    by default, but a custom tidal modelling location can\n    be specified using `tidepost_lat` and `tidepost_lon`.\n\n    This function uses the parallelised `model_tides` function\n    under the hood. It supports all tidal models supported by\n    `pyTMD`, including:\n\n    - Empirical Ocean Tide model (EOT20)\n    - Finite Element Solution tide models (FES2022, FES2014, FES2012)\n    - TOPEX/POSEIDON global tide models (TPXO10, TPXO9, TPXO8)\n    - Global Ocean Tide models (GOT5.6, GOT5.5, GOT4.10, GOT4.8, GOT4.7)\n    - Hamburg direct data Assimilation Methods for Tides models (HAMTIDE11)\n\n    Parameters\n    ----------\n    data : xarray.Dataset or xarray.DataArray or odc.geo.geobox.GeoBox\n        A multi-dimensional dataset or GeoBox pixel grid that will\n        be used to define the tide modelling location. If `data`\n        is an xarray object, it should include a \"time\" dimension.\n        If no \"time\" dimension exists or if `data` is a GeoBox,\n        then times must be passed using the `time` parameter.\n    time : DatetimeLike, optional\n        By default, tides will be modelled using times from the\n        \"time\" dimension of `data`. Alternatively, this param can\n        be used to provide a custom set of times. Accepts any format\n        that can be converted by `pandas.to_datetime()`. For example:\n        `time=pd.date_range(start=\"2000\", end=\"2001\", freq=\"5h\")`\n    model : str or list of str, optional\n        The tide model (or list of models) to use to model tides.\n        If a list is provided, a new \"tide_model\" dimension will be\n        added to the `xarray.DataArray` outputs. Defaults to \"EOT20\";\n        specify \"all\" to use all models available in `directory`.\n        For a full list of available and supported models, run\n        `eo_tides.utils.list_models`.\n    directory : str, optional\n        The directory containing tide model data files. If no path is\n        provided, this will default to the environment variable\n        `EO_TIDES_TIDE_MODELS` if set, or raise an error if not.\n        Tide modelling files should be stored in sub-folders for each\n        model that match the structure required by `pyTMD`\n        (&lt;https://geoscienceaustralia.github.io/eo-tides/setup/&gt;).\n    tidepost_lat, tidepost_lon : float, optional\n        Optional coordinates used to model tides. The default is None,\n        which uses the centroid of the dataset as the tide modelling\n        location.\n    **model_tides_kwargs :\n        Optional parameters passed to the `eo_tides.model.model_tides`\n        function. Important parameters include `cutoff` (used to\n        extrapolate modelled tides away from the coast; defaults to\n        `np.inf`), `crop` (whether to crop tide model constituent files\n        on-the-fly to improve performance) etc.\n\n    Returns\n    -------\n    tides_da : xr.DataArray\n        A one-dimensional tide height array. This will contain either\n        tide heights for every timestep in `data`, or for every time in\n        `times` if provided.\n    \"\"\"\n    # Standardise data inputs, time and models\n    gbox, time_coords = _standardise_inputs(data, time)\n    model = [model] if isinstance(model, str) else model\n\n    # If custom tide posts are not provided, use dataset centroid\n    if tidepost_lat is None or tidepost_lon is None:\n        lon, lat = gbox.geographic_extent.centroid.coords[0]\n        print(f\"Setting tide modelling location from dataset centroid: {lon:.2f}, {lat:.2f}\")\n    else:\n        lon, lat = tidepost_lon, tidepost_lat\n        print(f\"Using tide modelling location: {lon:.2f}, {lat:.2f}\")\n\n    # Model tide heights for each observation:\n    tide_df = model_tides(\n        x=lon,  # type: ignore\n        y=lat,  # type: ignore\n        time=time_coords,\n        model=model,\n        directory=directory,\n        crs=\"EPSG:4326\",\n        **model_tides_kwargs,\n    )\n\n    # If tides cannot be successfully modeled (e.g. if the centre of the\n    # xarray dataset is located is over land), raise an exception\n    if tide_df.tide_height.isnull().all():\n        raise ValueError(\n            f\"Tides could not be modelled for dataset centroid located \"\n            f\"at {tidepost_lon:.2f}, {tidepost_lat:.2f}. This can occur if \"\n            f\"this coordinate occurs over land. Please manually specify \"\n            f\"a tide modelling location located over water using the \"\n            f\"`tidepost_lat` and `tidepost_lon` parameters.\"\n        )\n\n    # Convert to xarray format\n    tides_da = tide_df.reset_index().set_index([\"time\", \"tide_model\"]).drop([\"x\", \"y\"], axis=1).tide_height.to_xarray()\n\n    # If only one tidal model exists, squeeze out \"tide_model\" dim\n    if len(tides_da.tide_model) == 1:\n        tides_da = tides_da.squeeze(\"tide_model\")\n\n    return tides_da\n</code></pre>"},{"location":"api/#eo_tides.eo.tag_tides(data)","title":"<code>data</code>","text":""},{"location":"api/#eo_tides.eo.tag_tides(time)","title":"<code>time</code>","text":""},{"location":"api/#eo_tides.eo.tag_tides(model)","title":"<code>model</code>","text":""},{"location":"api/#eo_tides.eo.tag_tides(directory)","title":"<code>directory</code>","text":""},{"location":"api/#eo_tides.eo.tag_tides(tidepost_lat)","title":"<code>tidepost_lat</code>","text":""},{"location":"api/#eo_tides.eo.tag_tides(tidepost_lon)","title":"<code>tidepost_lon</code>","text":""},{"location":"api/#eo_tides.eo.tag_tides(**model_tides_kwargs)","title":"<code>**model_tides_kwargs</code>","text":""},{"location":"api/#eo_tides.stats","title":"eo_tides.stats","text":"<p>Functions:</p> Name Description <code>pixel_stats</code> <p>Takes a multi-dimensional dataset and generate spatial</p> <code>tide_stats</code> <p>Takes a multi-dimensional dataset and generate tide statistics</p>"},{"location":"api/#eo_tides.stats.pixel_stats","title":"pixel_stats","text":"<pre><code>pixel_stats(\n    data,\n    time=None,\n    model=\"EOT20\",\n    directory=None,\n    resample=True,\n    modelled_freq=\"3h\",\n    min_max_q=(0.0, 1.0),\n    resample_method=\"bilinear\",\n    dask_chunks=None,\n    dask_compute=True,\n    extrapolate=True,\n    cutoff=10,\n    **pixel_tides_kwargs\n)\n</code></pre> <p>Takes a multi-dimensional dataset and generate spatial tide statistics and satellite-observed tide bias metrics, calculated based on every timestep in the satellite data and modelled into the spatial extent of the imagery.</p> <p>By comparing the subset of tides observed by satellites against the full astronomical tidal range, we can evaluate whether the tides observed by satellites are biased (e.g. fail to observe either the highest or lowest tides) due to tide aliasing interactions with sun-synchronous satellite overpasses.</p> <p>Compared to <code>tide_stats</code>, this function models tide metrics spatially to produce a two-dimensional output for each statistic.</p> <p>For more information about the tidal statistics computed by this function, refer to Figure 8 in Bishop-Taylor et al. 2018: https://www.sciencedirect.com/science/article/pii/S0272771418308783#fig8</p> <p>Parameters:</p> Name Type Description Default <code>Dataset or DataArray or GeoBox</code> <p>A multi-dimensional dataset or GeoBox pixel grid that will be used to calculate spatial tide statistics. If <code>data</code> is an xarray object, it should include a \"time\" dimension. If no \"time\" dimension exists or if <code>data</code> is a GeoBox, then times must be passed using the <code>time</code> parameter.</p> required <code>DatetimeLike</code> <p>By default, tides will be modelled using times from the \"time\" dimension of <code>data</code>. Alternatively, this param can be used to provide a custom set of times. Accepts any format that can be converted by <code>pandas.to_datetime()</code>. For example: <code>time=pd.date_range(start=\"2000\", end=\"2001\", freq=\"5h\")</code></p> <code>None</code> <code>str or list of str</code> <p>The tide model (or list of models) to use to model tides. If a list is provided, a new \"tide_model\" dimension will be added to the <code>xarray.Dataset</code> output. Defaults to \"EOT20\"; specify \"all\" to use all models available in <code>directory</code>. For a full list of available and supported models, run <code>eo_tides.utils.list_models</code>.</p> <code>'EOT20'</code> <code>str</code> <p>The directory containing tide model data files. If no path is provided, this will default to the environment variable <code>EO_TIDES_TIDE_MODELS</code> if set, or raise an error if not. Tide modelling files should be stored in sub-folders for each model that match the structure required by <code>pyTMD</code> (https://geoscienceaustralia.github.io/eo-tides/setup/).</p> <code>None</code> <code>bool</code> <p>Whether to resample tide statistics back into <code>data</code>'s original higher resolution grid. Set this to <code>False</code> if you want to return lower-resolution tide statistics (which can be useful for assessing tide biases across large spatial extents).</p> <code>True</code> <code>str</code> <p>An optional string giving the frequency at which to model tides when computing the full modelled tidal range. Defaults to '3h', which computes a tide height for every three hours across the temporal extent of <code>data</code>.</p> <code>'3h'</code> <code>tuple</code> <p>Quantiles used to calculate max and min observed and modelled astronomical tides. By default <code>(0.0, 1.0)</code> which is equivalent to minimum and maximum; for a softer threshold that is more robust to outliers use e.g. <code>(0.1, 0.9)</code>.</p> <code>(0.0, 1.0)</code> <code>str</code> <p>If resampling is requested (see <code>resample</code> above), use this resampling method when resampling from low resolution to high resolution pixels. Defaults to \"bilinear\"; valid options include \"nearest\", \"cubic\", \"min\", \"max\", \"average\" etc.</p> <code>'bilinear'</code> <code>tuple of float</code> <p>Can be used to configure custom Dask chunking for the final resampling step. By default, chunks will be automatically set to match y/x chunks from <code>data</code> if they exist; otherwise chunks will be chosen to cover the entire y/x extent of the dataset. For custom chunks, provide a tuple in the form <code>(y, x)</code>, e.g. <code>(2048, 2048)</code>.</p> <code>None</code> <code>bool</code> <p>Whether to compute results of the resampling step using Dask. If False, <code>stats_ds</code> will be returned as a Dask-enabled array.</p> <code>True</code> <code>bool</code> <p>Whether to extrapolate tides into x and y coordinates outside of the valid tide modelling domain using nearest-neighbor. Defaults to True.</p> <code>True</code> <code>float</code> <p>Extrapolation cutoff in kilometers. To avoid producing tide statistics too far inland, the default is 10 km.</p> <code>10</code> <p>Optional parameters passed to the <code>eo_tides.eo.pixel_tides</code> function.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>stats_ds</code> <code>Dataset</code> <p>An <code>xarray.Dataset</code> containing the following statistics as two-dimensional data variables:</p> <ul> <li><code>mot</code>: mean tide height observed by the satellite (metres)</li> <li><code>mat</code>: mean modelled astronomical tide height (metres)</li> <li><code>lot</code>: minimum tide height observed by the satellite (metres)</li> <li><code>lat</code>: minimum tide height from modelled astronomical tidal range (metres)</li> <li><code>hot</code>: maximum tide height observed by the satellite (metres)</li> <li><code>hat</code>: maximum tide height from modelled astronomical tidal range (metres)</li> <li><code>otr</code>: tidal range observed by the satellite (metres)</li> <li><code>tr</code>: modelled astronomical tide range (metres)</li> <li><code>spread</code>: proportion of the full modelled tidal range observed by the satellite</li> <li><code>offset_low</code>: proportion of the lowest tides never observed by the satellite</li> <li><code>offset_high</code>: proportion of the highest tides never observed by the satellite</li> </ul> Source code in <code>eo_tides/stats.py</code> <pre><code>def pixel_stats(\n    data: xr.Dataset | xr.DataArray | GeoBox,\n    time: DatetimeLike | None = None,\n    model: str | list[str] = \"EOT20\",\n    directory: str | os.PathLike | None = None,\n    resample: bool = True,\n    modelled_freq: str = \"3h\",\n    min_max_q: tuple[float, float] = (0.0, 1.0),\n    resample_method: str = \"bilinear\",\n    dask_chunks: tuple[float, float] | None = None,\n    dask_compute: bool = True,\n    extrapolate: bool = True,\n    cutoff: float = 10,\n    **pixel_tides_kwargs,\n) -&gt; xr.Dataset:\n    \"\"\"\n    Takes a multi-dimensional dataset and generate spatial\n    tide statistics and satellite-observed tide bias metrics,\n    calculated based on every timestep in the satellite data and\n    modelled into the spatial extent of the imagery.\n\n    By comparing the subset of tides observed by satellites\n    against the full astronomical tidal range, we can evaluate\n    whether the tides observed by satellites are biased\n    (e.g. fail to observe either the highest or lowest tides)\n    due to tide aliasing interactions with sun-synchronous satellite\n    overpasses.\n\n    Compared to `tide_stats`, this function models tide metrics\n    spatially to produce a two-dimensional output for each statistic.\n\n    For more information about the tidal statistics computed by this\n    function, refer to Figure 8 in Bishop-Taylor et al. 2018:\n    &lt;https://www.sciencedirect.com/science/article/pii/S0272771418308783#fig8&gt;\n\n    Parameters\n    ----------\n    data : xarray.Dataset or xarray.DataArray or odc.geo.geobox.GeoBox\n        A multi-dimensional dataset or GeoBox pixel grid that will\n        be used to calculate spatial tide statistics. If `data`\n        is an xarray object, it should include a \"time\" dimension.\n        If no \"time\" dimension exists or if `data` is a GeoBox,\n        then times must be passed using the `time` parameter.\n    time : DatetimeLike, optional\n        By default, tides will be modelled using times from the\n        \"time\" dimension of `data`. Alternatively, this param can\n        be used to provide a custom set of times. Accepts any format\n        that can be converted by `pandas.to_datetime()`. For example:\n        `time=pd.date_range(start=\"2000\", end=\"2001\", freq=\"5h\")`\n    model : str or list of str, optional\n        The tide model (or list of models) to use to model tides.\n        If a list is provided, a new \"tide_model\" dimension will be\n        added to the `xarray.Dataset` output. Defaults to \"EOT20\";\n        specify \"all\" to use all models available in `directory`.\n        For a full list of available and supported models, run\n        `eo_tides.utils.list_models`.\n    directory : str, optional\n        The directory containing tide model data files. If no path is\n        provided, this will default to the environment variable\n        `EO_TIDES_TIDE_MODELS` if set, or raise an error if not.\n        Tide modelling files should be stored in sub-folders for each\n        model that match the structure required by `pyTMD`\n        (&lt;https://geoscienceaustralia.github.io/eo-tides/setup/&gt;).\n    resample : bool, optional\n        Whether to resample tide statistics back into `data`'s original\n        higher resolution grid. Set this to `False` if you want to return\n        lower-resolution tide statistics (which can be useful for\n        assessing tide biases across large spatial extents).\n    modelled_freq : str, optional\n        An optional string giving the frequency at which to model tides\n        when computing the full modelled tidal range. Defaults to '3h',\n        which computes a tide height for every three hours across the\n        temporal extent of `data`.\n    min_max_q : tuple, optional\n        Quantiles used to calculate max and min observed and modelled\n        astronomical tides. By default `(0.0, 1.0)` which is equivalent\n        to minimum and maximum; for a softer threshold that is more\n        robust to outliers use e.g. `(0.1, 0.9)`.\n    resample_method : str, optional\n        If resampling is requested (see `resample` above), use this\n        resampling method when resampling from low resolution to high\n        resolution pixels. Defaults to \"bilinear\"; valid options include\n        \"nearest\", \"cubic\", \"min\", \"max\", \"average\" etc.\n    dask_chunks : tuple of float, optional\n        Can be used to configure custom Dask chunking for the final\n        resampling step. By default, chunks will be automatically set\n        to match y/x chunks from `data` if they exist; otherwise chunks\n        will be chosen to cover the entire y/x extent of the dataset.\n        For custom chunks, provide a tuple in the form `(y, x)`, e.g.\n        `(2048, 2048)`.\n    dask_compute : bool, optional\n        Whether to compute results of the resampling step using Dask.\n        If False, `stats_ds` will be returned as a Dask-enabled array.\n    extrapolate : bool, optional\n        Whether to extrapolate tides into x and y coordinates outside of\n        the valid tide modelling domain using nearest-neighbor. Defaults\n        to True.\n    cutoff : float, optional\n        Extrapolation cutoff in kilometers. To avoid producing tide\n        statistics too far inland, the default is 10 km.\n    **pixel_tides_kwargs :\n        Optional parameters passed to the `eo_tides.eo.pixel_tides`\n        function.\n\n    Returns\n    -------\n    stats_ds : xarray.Dataset\n        An `xarray.Dataset` containing the following statistics as two-dimensional data variables:\n\n        - `mot`: mean tide height observed by the satellite (metres)\n        - `mat`: mean modelled astronomical tide height (metres)\n        - `lot`: minimum tide height observed by the satellite (metres)\n        - `lat`: minimum tide height from modelled astronomical tidal range (metres)\n        - `hot`: maximum tide height observed by the satellite (metres)\n        - `hat`: maximum tide height from modelled astronomical tidal range (metres)\n        - `otr`: tidal range observed by the satellite (metres)\n        - `tr`: modelled astronomical tide range (metres)\n        - `spread`: proportion of the full modelled tidal range observed by the satellite\n        - `offset_low`: proportion of the lowest tides never observed by the satellite\n        - `offset_high`: proportion of the highest tides never observed by the satellite\n\n    \"\"\"\n\n    # Standardise data inputs, time and models\n    gbox, obs_times = _standardise_inputs(data, time)\n    dask_chunks = _resample_chunks(data, dask_chunks)\n    model = [model] if isinstance(model, str) else model\n\n    # Generate range of times covering entire period of satellite record\n    assert obs_times is not None\n    all_times = pd.date_range(\n        start=obs_times.min().item(),\n        end=obs_times.max().item(),\n        freq=modelled_freq,\n    )\n\n    # Model tides for observed timesteps\n    obs_tides_da = pixel_tides(\n        gbox,\n        time=obs_times,\n        model=model,\n        directory=directory,\n        resample=False,\n        extrapolate=extrapolate,\n        cutoff=cutoff,\n        **pixel_tides_kwargs,\n    )\n\n    # Model tides for all modelled timesteps\n    all_tides_da = pixel_tides(\n        gbox,\n        time=all_times,\n        model=model,\n        directory=directory,\n        resample=False,\n        extrapolate=extrapolate,\n        cutoff=cutoff,\n        **pixel_tides_kwargs,\n    )\n\n    # Calculate statistics\n    stats_lowres = _tide_statistics(obs_tides_da, all_tides_da, min_max_q=min_max_q)\n\n    # Assign CRS and geobox to allow reprojection\n    stats_lowres = stats_lowres.odc.assign_crs(crs=gbox.crs)\n\n    # Reproject statistics into original high resolution grid\n    if resample:\n        print(\"Reprojecting statistics into original resolution\")\n        stats_highres = _pixel_tides_resample(\n            stats_lowres,\n            gbox,\n            resample_method,\n            dask_chunks,\n            dask_compute,\n            None,\n        )\n        return stats_highres\n\n    print(\"Returning low resolution statistics array\")\n    return stats_lowres\n</code></pre>"},{"location":"api/#eo_tides.stats.pixel_stats(data)","title":"<code>data</code>","text":""},{"location":"api/#eo_tides.stats.pixel_stats(time)","title":"<code>time</code>","text":""},{"location":"api/#eo_tides.stats.pixel_stats(model)","title":"<code>model</code>","text":""},{"location":"api/#eo_tides.stats.pixel_stats(directory)","title":"<code>directory</code>","text":""},{"location":"api/#eo_tides.stats.pixel_stats(resample)","title":"<code>resample</code>","text":""},{"location":"api/#eo_tides.stats.pixel_stats(modelled_freq)","title":"<code>modelled_freq</code>","text":""},{"location":"api/#eo_tides.stats.pixel_stats(min_max_q)","title":"<code>min_max_q</code>","text":""},{"location":"api/#eo_tides.stats.pixel_stats(resample_method)","title":"<code>resample_method</code>","text":""},{"location":"api/#eo_tides.stats.pixel_stats(dask_chunks)","title":"<code>dask_chunks</code>","text":""},{"location":"api/#eo_tides.stats.pixel_stats(dask_compute)","title":"<code>dask_compute</code>","text":""},{"location":"api/#eo_tides.stats.pixel_stats(extrapolate)","title":"<code>extrapolate</code>","text":""},{"location":"api/#eo_tides.stats.pixel_stats(cutoff)","title":"<code>cutoff</code>","text":""},{"location":"api/#eo_tides.stats.pixel_stats(**pixel_tides_kwargs)","title":"<code>**pixel_tides_kwargs</code>","text":""},{"location":"api/#eo_tides.stats.tide_stats","title":"tide_stats","text":"<pre><code>tide_stats(\n    data,\n    time=None,\n    model=\"EOT20\",\n    directory=None,\n    tidepost_lat=None,\n    tidepost_lon=None,\n    plain_english=True,\n    plot=True,\n    plot_var=None,\n    point_col=None,\n    modelled_freq=\"3h\",\n    min_max_q=(0.0, 1.0),\n    round_stats=3,\n    **tag_tides_kwargs\n)\n</code></pre> <p>Takes a multi-dimensional dataset and generate tide statistics and satellite-observed tide bias metrics, calculated based on every timestep in the satellite data and the geographic centroid of the imagery.</p> <p>By comparing the subset of tides observed by satellites against the full astronomical tidal range, we can evaluate whether the tides observed by satellites are biased (e.g. fail to observe either the highest or lowest tides) due to tide aliasing interactions with sun-synchronous satellite overpasses.</p> <p>For more information about the tidal statistics computed by this function, refer to Figure 8 in Bishop-Taylor et al. 2018: https://www.sciencedirect.com/science/article/pii/S0272771418308783#fig8</p> <p>Parameters:</p> Name Type Description Default <code>Dataset or DataArray or GeoBox</code> <p>A multi-dimensional dataset or GeoBox pixel grid that will be used to calculate tide statistics. If <code>data</code> is an xarray object, it should include a \"time\" dimension. If no \"time\" dimension exists or if <code>data</code> is a GeoBox, then times must be passed using the <code>time</code> parameter.</p> required <code>DatetimeLike</code> <p>By default, tides will be modelled using times from the \"time\" dimension of <code>data</code>. Alternatively, this param can be used to provide a custom set of times. Accepts any format that can be converted by <code>pandas.to_datetime()</code>. For example: <code>time=pd.date_range(start=\"2000\", end=\"2001\", freq=\"5h\")</code></p> <code>None</code> <code>str or list of str</code> <p>The tide model (or list of models) to use to model tides. If a list is provided, the resulting statistics will be returned as a <code>pandas.Dataframe</code>; otherwise a <code>pandas.Series</code>. Defaults to \"EOT20\"; specify \"all\" to use all models available in <code>directory</code>. For a full list of available and supported models, run <code>eo_tides.utils.list_models</code>.</p> <code>'EOT20'</code> <code>str</code> <p>The directory containing tide model data files. If no path is provided, this will default to the environment variable <code>EO_TIDES_TIDE_MODELS</code> if set, or raise an error if not. Tide modelling files should be stored in sub-folders for each model that match the structure required by <code>pyTMD</code> (https://geoscienceaustralia.github.io/eo-tides/setup/).</p> <code>None</code> <code>float or int</code> <p>Optional coordinates used to model tides. The default is None, which uses the centroid of the dataset as the tide modelling location.</p> <code>None</code> <code>float or int</code> <p>Optional coordinates used to model tides. The default is None, which uses the centroid of the dataset as the tide modelling location.</p> <code>None</code> <code>bool</code> <p>An optional boolean indicating whether to print a plain english version of the tidal statistics to the screen. Defaults to True; only supported when a single tide model is passed to <code>model</code>.</p> <code>True</code> <code>bool</code> <p>An optional boolean indicating whether to plot how satellite- observed tide heights compare against the full tidal range. Defaults to True; only supported when a single tide model is passed to <code>model</code>.</p> <code>True</code> <code>str</code> <p>Optional name of a coordinate, dimension or variable in the array that will be used to plot observations with unique symbols. Defaults to None, which will plot all observations as circles.</p> <code>None</code> <code>str</code> <p>Colour used to plot points on the graph. Defaults to None which will automatically select colours.</p> <code>None</code> <code>str</code> <p>An optional string giving the frequency at which to model tides when computing the full modelled tidal range. Defaults to '3h', which computes a tide height for every three hours across the temporal extent of <code>data</code>.</p> <code>'3h'</code> <code>tuple</code> <p>Quantiles used to calculate max and min observed and modelled astronomical tides. By default <code>(0.0, 1.0)</code> which is equivalent to minimum and maximum; to use a softer threshold that is more robust to outliers, use e.g. <code>(0.1, 0.9)</code>.</p> <code>(0.0, 1.0)</code> <code>int</code> <p>The number of decimal places used to round the output statistics. Defaults to 3.</p> <code>3</code> <p>Optional parameters passed to the <code>eo_tides.eo.tag_tides</code> function that is used to model tides for each observed and modelled timestep.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>stats_df</code> <code>Series or Dataframe</code> <p>A pandas object containing the following statistics:</p> <ul> <li><code>y</code>: latitude used for modelling tide heights</li> <li><code>x</code>: longitude used for modelling tide heights</li> <li><code>mot</code>: mean tide height observed by the satellite (metres)</li> <li><code>mat</code>: mean modelled astronomical tide height (metres)</li> <li><code>lot</code>: minimum tide height observed by the satellite (metres)</li> <li><code>lat</code>: minimum tide height from modelled astronomical tidal range (metres)</li> <li><code>hot</code>: maximum tide height observed by the satellite (metres)</li> <li><code>hat</code>: maximum tide height from modelled astronomical tidal range (metres)</li> <li><code>otr</code>: tidal range observed by the satellite (metres)</li> <li><code>tr</code>: modelled astronomical tide range (metres)</li> <li><code>spread</code>: proportion of the full modelled tidal range observed by the satellite</li> <li><code>offset_low</code>: proportion of the lowest tides never observed by the satellite</li> <li><code>offset_high</code>: proportion of the highest tides never observed by the satellite</li> </ul> Source code in <code>eo_tides/stats.py</code> <pre><code>def tide_stats(\n    data: xr.Dataset | xr.DataArray | GeoBox,\n    time: DatetimeLike | None = None,\n    model: str = \"EOT20\",\n    directory: str | os.PathLike | None = None,\n    tidepost_lat: float | None = None,\n    tidepost_lon: float | None = None,\n    plain_english: bool = True,\n    plot: bool = True,\n    plot_var: str | None = None,\n    point_col: str | None = None,\n    modelled_freq: str = \"3h\",\n    min_max_q: tuple = (0.0, 1.0),\n    round_stats: int = 3,\n    **tag_tides_kwargs,\n) -&gt; pd.Series:\n    \"\"\"\n    Takes a multi-dimensional dataset and generate tide statistics\n    and satellite-observed tide bias metrics, calculated based on\n    every timestep in the satellite data and the geographic centroid\n    of the imagery.\n\n    By comparing the subset of tides observed by satellites\n    against the full astronomical tidal range, we can evaluate\n    whether the tides observed by satellites are biased\n    (e.g. fail to observe either the highest or lowest tides) due\n    to tide aliasing interactions with sun-synchronous satellite\n    overpasses.\n\n    For more information about the tidal statistics computed by this\n    function, refer to Figure 8 in Bishop-Taylor et al. 2018:\n    &lt;https://www.sciencedirect.com/science/article/pii/S0272771418308783#fig8&gt;\n\n    Parameters\n    ----------\n    data : xarray.Dataset or xarray.DataArray or odc.geo.geobox.GeoBox\n        A multi-dimensional dataset or GeoBox pixel grid that will\n        be used to calculate tide statistics. If `data` is an\n        xarray object, it should include a \"time\" dimension.\n        If no \"time\" dimension exists or if `data` is a GeoBox,\n        then times must be passed using the `time` parameter.\n    time : DatetimeLike, optional\n        By default, tides will be modelled using times from the\n        \"time\" dimension of `data`. Alternatively, this param can\n        be used to provide a custom set of times. Accepts any format\n        that can be converted by `pandas.to_datetime()`. For example:\n        `time=pd.date_range(start=\"2000\", end=\"2001\", freq=\"5h\")`\n    model : str or list of str, optional\n        The tide model (or list of models) to use to model tides.\n        If a list is provided, the resulting statistics will be\n        returned as a `pandas.Dataframe`; otherwise a `pandas.Series`.\n        Defaults to \"EOT20\"; specify \"all\" to use all models available\n        in `directory`. For a full list of available and supported\n        models, run `eo_tides.utils.list_models`.\n    directory : str, optional\n        The directory containing tide model data files. If no path is\n        provided, this will default to the environment variable\n        `EO_TIDES_TIDE_MODELS` if set, or raise an error if not.\n        Tide modelling files should be stored in sub-folders for each\n        model that match the structure required by `pyTMD`\n        (&lt;https://geoscienceaustralia.github.io/eo-tides/setup/&gt;).\n    tidepost_lat, tidepost_lon : float or int, optional\n        Optional coordinates used to model tides. The default is None,\n        which uses the centroid of the dataset as the tide modelling\n        location.\n    plain_english : bool, optional\n        An optional boolean indicating whether to print a plain english\n        version of the tidal statistics to the screen. Defaults to True;\n        only supported when a single tide model is passed to `model`.\n    plot : bool, optional\n        An optional boolean indicating whether to plot how satellite-\n        observed tide heights compare against the full tidal range.\n        Defaults to True; only supported when a single tide model is\n        passed to `model`.\n    plot_var : str, optional\n        Optional name of a coordinate, dimension or variable in the array\n        that will be used to plot observations with unique symbols.\n        Defaults to None, which will plot all observations as circles.\n    point_col : str, optional\n        Colour used to plot points on the graph. Defaults to None which\n        will automatically select colours.\n    modelled_freq : str, optional\n        An optional string giving the frequency at which to model tides\n        when computing the full modelled tidal range. Defaults to '3h',\n        which computes a tide height for every three hours across the\n        temporal extent of `data`.\n    min_max_q : tuple, optional\n        Quantiles used to calculate max and min observed and modelled\n        astronomical tides. By default `(0.0, 1.0)` which is equivalent\n        to minimum and maximum; to use a softer threshold that is more\n        robust to outliers, use e.g. `(0.1, 0.9)`.\n    round_stats : int, optional\n        The number of decimal places used to round the output statistics.\n        Defaults to 3.\n    **tag_tides_kwargs :\n        Optional parameters passed to the `eo_tides.eo.tag_tides`\n        function that is used to model tides for each observed and\n        modelled timestep.\n\n    Returns\n    -------\n    stats_df : pandas.Series or pandas.Dataframe\n        A pandas object containing the following statistics:\n\n        - `y`: latitude used for modelling tide heights\n        - `x`: longitude used for modelling tide heights\n        - `mot`: mean tide height observed by the satellite (metres)\n        - `mat`: mean modelled astronomical tide height (metres)\n        - `lot`: minimum tide height observed by the satellite (metres)\n        - `lat`: minimum tide height from modelled astronomical tidal range (metres)\n        - `hot`: maximum tide height observed by the satellite (metres)\n        - `hat`: maximum tide height from modelled astronomical tidal range (metres)\n        - `otr`: tidal range observed by the satellite (metres)\n        - `tr`: modelled astronomical tide range (metres)\n        - `spread`: proportion of the full modelled tidal range observed by the satellite\n        - `offset_low`: proportion of the lowest tides never observed by the satellite\n        - `offset_high`: proportion of the highest tides never observed by the satellite\n    \"\"\"\n\n    # Standardise data inputs, time and models\n    gbox, obs_times = _standardise_inputs(data, time)\n\n    # Generate range of times covering entire period of satellite record\n    assert obs_times is not None\n    all_times = pd.date_range(\n        start=obs_times.min().item(),\n        end=obs_times.max().item(),\n        freq=modelled_freq,\n    )\n\n    # If custom tide modelling locations are not provided, use the\n    # dataset centroid\n    if not tidepost_lat or not tidepost_lon:\n        tidepost_lon, tidepost_lat = gbox.geographic_extent.centroid.coords[0]\n\n    # Model tides for observed timesteps\n    obs_tides_da = tag_tides(\n        gbox,\n        time=obs_times,\n        model=model,\n        directory=directory,\n        tidepost_lat=tidepost_lat,  # type: ignore\n        tidepost_lon=tidepost_lon,  # type: ignore\n        **tag_tides_kwargs,\n    )\n\n    # Model tides for all modelled timesteps\n    all_tides_da = tag_tides(\n        gbox,\n        time=all_times,\n        model=model,\n        directory=directory,\n        tidepost_lat=tidepost_lat,  # type: ignore\n        tidepost_lon=tidepost_lon,  # type: ignore\n        **tag_tides_kwargs,\n    )\n\n    # Calculate statistics\n    stats_ds = _tide_statistics(obs_tides_da, all_tides_da, min_max_q=min_max_q)\n\n    # Convert to pandas and add tide post coordinates\n    stats_df = stats_ds.to_pandas().astype(\"float32\")\n    stats_df[\"x\"] = tidepost_lon\n    stats_df[\"y\"] = tidepost_lat\n\n    # Convert coordinates to index if dataframe\n    if isinstance(stats_df, pd.DataFrame):\n        stats_df = stats_df.set_index([\"x\", \"y\"], append=True)\n\n    # If a series, print and plot summaries\n    else:\n        if plain_english:\n            _stats_plain_english(\n                mot=stats_df.mot,\n                mat=stats_df.mat,\n                hot=stats_df.hot,\n                hat=stats_df.hat,\n                lot=stats_df.lot,\n                lat=stats_df.lat,\n                otr=stats_df.otr,\n                tr=stats_df.tr,\n                spread=stats_df.spread,\n                offset_low=stats_df.offset_low,\n                offset_high=stats_df.offset_high,\n            )\n\n        if plot:\n            _stats_figure(\n                all_tides_da=all_tides_da,\n                obs_tides_da=obs_tides_da,\n                hot=stats_df.hot,\n                hat=stats_df.hat,\n                lot=stats_df.lot,\n                lat=stats_df.lat,\n                spread=stats_df.spread,\n                offset_low=stats_df.offset_low,\n                offset_high=stats_df.offset_high,\n                plot_var=data[plot_var] if plot_var else None,\n                point_col=point_col,\n            )\n\n    # Return in Pandas format\n    return stats_df.round(round_stats)\n</code></pre>"},{"location":"api/#eo_tides.stats.tide_stats(data)","title":"<code>data</code>","text":""},{"location":"api/#eo_tides.stats.tide_stats(time)","title":"<code>time</code>","text":""},{"location":"api/#eo_tides.stats.tide_stats(model)","title":"<code>model</code>","text":""},{"location":"api/#eo_tides.stats.tide_stats(directory)","title":"<code>directory</code>","text":""},{"location":"api/#eo_tides.stats.tide_stats(tidepost_lat)","title":"<code>tidepost_lat</code>","text":""},{"location":"api/#eo_tides.stats.tide_stats(tidepost_lon)","title":"<code>tidepost_lon</code>","text":""},{"location":"api/#eo_tides.stats.tide_stats(plain_english)","title":"<code>plain_english</code>","text":""},{"location":"api/#eo_tides.stats.tide_stats(plot)","title":"<code>plot</code>","text":""},{"location":"api/#eo_tides.stats.tide_stats(plot_var)","title":"<code>plot_var</code>","text":""},{"location":"api/#eo_tides.stats.tide_stats(point_col)","title":"<code>point_col</code>","text":""},{"location":"api/#eo_tides.stats.tide_stats(modelled_freq)","title":"<code>modelled_freq</code>","text":""},{"location":"api/#eo_tides.stats.tide_stats(min_max_q)","title":"<code>min_max_q</code>","text":""},{"location":"api/#eo_tides.stats.tide_stats(round_stats)","title":"<code>round_stats</code>","text":""},{"location":"api/#eo_tides.stats.tide_stats(**tag_tides_kwargs)","title":"<code>**tag_tides_kwargs</code>","text":""},{"location":"api/#eo_tides.validation","title":"eo_tides.validation","text":"<p>Functions:</p> Name Description <code>eval_metrics</code> <p>Calculate a set of common statistical metrics</p> <code>load_gauge_gesla</code> <p>Load Global Extreme Sea Level Analysis (GESLA) tide gauge data.</p>"},{"location":"api/#eo_tides.validation.eval_metrics","title":"eval_metrics","text":"<pre><code>eval_metrics(x, y, round=3, all_regress=False)\n</code></pre> <p>Calculate a set of common statistical metrics based on two input actual and predicted vectors.</p> <p>These include:</p> <ul> <li>Pearson correlation</li> <li>Root Mean Squared Error</li> <li>Mean Absolute Error</li> <li>R-squared</li> <li>Bias</li> <li>Linear regression parameters (slope, p-value, intercept, standard error)</li> </ul> <p>Parameters:</p> Name Type Description Default <code>array</code> <p>An array providing \"actual\" variable values.</p> required <code>array</code> <p>An array providing \"predicted\" variable values.</p> required <code>int</code> <p>Number of decimal places to round each metric to. Defaults to 3.</p> <code>3</code> <code>bool</code> <p>Whether to return linear regression p-value, intercept and standard error (in addition to only regression slope). Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Series</code> <p>A <code>pd.Series</code> containing all calculated metrics.</p> Source code in <code>eo_tides/validation.py</code> <pre><code>def eval_metrics(x, y, round=3, all_regress=False):\n    \"\"\"\n    Calculate a set of common statistical metrics\n    based on two input actual and predicted vectors.\n\n    These include:\n\n    * Pearson correlation\n    * Root Mean Squared Error\n    * Mean Absolute Error\n    * R-squared\n    * Bias\n    * Linear regression parameters (slope, p-value, intercept, standard error)\n\n    Parameters\n    ----------\n    x : numpy.array\n        An array providing \"actual\" variable values.\n    y : numpy.array\n        An array providing \"predicted\" variable values.\n    round : int\n        Number of decimal places to round each metric\n        to. Defaults to 3.\n    all_regress : bool\n        Whether to return linear regression p-value,\n        intercept and standard error (in addition to\n        only regression slope). Defaults to False.\n\n    Returns\n    -------\n    pandas.Series\n        A `pd.Series` containing all calculated metrics.\n    \"\"\"\n\n    # Create dataframe to drop na\n    xy_df = pd.DataFrame({\"x\": x, \"y\": y}).dropna()\n\n    # Compute linear regression\n    lin_reg = stats.linregress(x=xy_df.x, y=xy_df.y)\n\n    # Calculate statistics\n    stats_dict = {\n        \"Correlation\": xy_df.corr().iloc[0, 1],\n        \"RMSE\": sqrt(mean_squared_error(xy_df.x, xy_df.y)),\n        \"MAE\": mean_absolute_error(xy_df.x, xy_df.y),\n        \"R-squared\": lin_reg.rvalue**2,\n        \"Bias\": (xy_df.y - xy_df.x).mean(),\n        \"Regression slope\": lin_reg.slope,\n    }\n\n    # Additional regression params\n    if all_regress:\n        stats_dict.update({\n            \"Regression p-value\": lin_reg.pvalue,\n            \"Regression intercept\": lin_reg.intercept,\n            \"Regression standard error\": lin_reg.stderr,\n        })\n\n    # Return as\n    return pd.Series(stats_dict).round(round)\n</code></pre>"},{"location":"api/#eo_tides.validation.eval_metrics(x)","title":"<code>x</code>","text":""},{"location":"api/#eo_tides.validation.eval_metrics(y)","title":"<code>y</code>","text":""},{"location":"api/#eo_tides.validation.eval_metrics(round)","title":"<code>round</code>","text":""},{"location":"api/#eo_tides.validation.eval_metrics(all_regress)","title":"<code>all_regress</code>","text":""},{"location":"api/#eo_tides.validation.load_gauge_gesla","title":"load_gauge_gesla","text":"<pre><code>load_gauge_gesla(\n    x=None,\n    y=None,\n    site_code=None,\n    time=(\"2018\", \"2020\"),\n    max_distance=None,\n    correct_mean=False,\n    filter_use_flag=True,\n    site_metadata=True,\n    data_path=\"/gdata1/data/sea_level/gesla/\",\n    metadata_path=\"/gdata1/data/sea_level/GESLA3_ALL 2.csv\",\n)\n</code></pre> <p>Load Global Extreme Sea Level Analysis (GESLA) tide gauge data.</p> <p>Load and process all available GESLA measured sea-level data with an <code>x, y, time</code> spatio-temporal query, or from a list of specific tide gauges. Can optionally filter by gauge quality and append detailed gauge metadata.</p> <p>Modified from original code in https://github.com/philiprt/GeslaDataset.</p> <p>Parameters:</p> Name Type Description Default <code>numeric or list / tuple</code> <p>Coordinates (in degrees longitude, latitude) used to load GESLA tide gauge observations. If provided as singular values (e.g. <code>x=150, y=-32</code>), then the nearest tide gauge will be returned. If provided as a list or tuple (e.g. <code>x=(150, 152), y=(-32, -30)</code>), then all gauges within the provided bounding box will be loaded. Leave as <code>None</code> to return all available gauges, or if providing a list of site codes using <code>site_code</code>.</p> <code>None</code> <code>numeric or list / tuple</code> <p>Coordinates (in degrees longitude, latitude) used to load GESLA tide gauge observations. If provided as singular values (e.g. <code>x=150, y=-32</code>), then the nearest tide gauge will be returned. If provided as a list or tuple (e.g. <code>x=(150, 152), y=(-32, -30)</code>), then all gauges within the provided bounding box will be loaded. Leave as <code>None</code> to return all available gauges, or if providing a list of site codes using <code>site_code</code>.</p> <code>None</code> <code>str or list of str</code> <p>GESLA site code(s) for which to load data (e.g. <code>site_code=\"62650\"</code>). If <code>site_code</code> is provided, <code>x</code> and <code>y</code> will be ignored.</p> <code>None</code> <code>tuple or list of str</code> <p>Time range to consider, given as a tuple of start and end dates, e.g. <code>time=(\"2020\", \"2021\")</code>. The default of None will return all tide observations from the year 1800 onward.</p> <code>('2018', '2020')</code> <code>numeric</code> <p>Optional max distance within which to return the nearest tide gauge when <code>x</code> and <code>y</code> are provided as singular coordinates. Defaults to None, which will always return a tide gauge no matter how far away it is located from <code>x</code> and <code>y</code>.</p> <code>None</code> <code>bool</code> <p>Whether to correct sea level measurements to a standardised mean sea level by subtracting the mean of all observed sea level observations. This can be useful when GESLA tide heights come from different or unknown tide datums. Note: the observed mean sea level calculated here may differ from true long-term/ astronomical Mean Sea Level (MSL) datum.</p> <code>False</code> <code>bool</code> <p>Whether to filter out low quality observations with a \"use_flag\" value of 0 (do not use). Defaults to True.</p> <code>True</code> <code>bool</code> <p>Whether to add tide gauge station metadata as additional columns in the output DataFrame. Defaults to True.</p> <code>True</code> <code>str</code> <p>Path to the raw GESLA data files. Default is <code>/gdata1/data/sea_level/gesla/</code>.</p> <code>'/gdata1/data/sea_level/gesla/'</code> <code>str</code> <p>Path to the GESLA station metadata file. Default is <code>/gdata1/data/sea_level/GESLA3_ALL 2.csv</code>.</p> <code>'/gdata1/data/sea_level/GESLA3_ALL 2.csv'</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Processed GESLA data as a DataFrame with columns including:</p> <ul> <li>\"time\": Timestamps,</li> <li>\"sea_level\": Observed sea level (m),</li> <li>\"qc_flag\": Observed sea level QC flag,</li> <li>\"use_flag\": Use-in-analysis flag (1 = use, 0 = do not use),</li> </ul> <p>...and additional columns from station metadata.</p> Source code in <code>eo_tides/validation.py</code> <pre><code>def load_gauge_gesla(\n    x=None,\n    y=None,\n    site_code=None,\n    time=(\"2018\", \"2020\"),\n    max_distance=None,\n    correct_mean=False,\n    filter_use_flag=True,\n    site_metadata=True,\n    data_path=\"/gdata1/data/sea_level/gesla/\",\n    metadata_path=\"/gdata1/data/sea_level/GESLA3_ALL 2.csv\",\n):\n    \"\"\"\n    Load Global Extreme Sea Level Analysis (GESLA) tide gauge data.\n\n    Load and process all available GESLA measured sea-level data\n    with an `x, y, time` spatio-temporal query, or from a list of\n    specific tide gauges. Can optionally filter by gauge quality\n    and append detailed gauge metadata.\n\n    Modified from original code in &lt;https://github.com/philiprt/GeslaDataset&gt;.\n\n    Parameters\n    ----------\n    x, y : numeric or list/tuple, optional\n        Coordinates (in degrees longitude, latitude) used to load GESLA\n        tide gauge observations. If provided as singular values\n        (e.g. `x=150, y=-32`), then the nearest tide gauge will be returned.\n        If provided as a list or tuple (e.g. `x=(150, 152), y=(-32, -30)`),\n        then all gauges within the provided bounding box will be loaded.\n        Leave as `None` to return all available gauges, or if providing a\n        list of site codes using `site_code`.\n    site_code : str or list of str, optional\n        GESLA site code(s) for which to load data (e.g. `site_code=\"62650\"`).\n        If `site_code` is provided, `x` and `y` will be ignored.\n    time : tuple or list of str, optional\n        Time range to consider, given as a tuple of start and end dates,\n        e.g. `time=(\"2020\", \"2021\")`. The default of None will return all\n        tide observations from the year 1800 onward.\n    max_distance : numeric, optional\n        Optional max distance within which to return the nearest tide gauge\n        when `x` and `y` are provided as singular coordinates. Defaults to\n        None, which will always return a tide gauge no matter how far away\n        it is located from `x` and `y`.\n    correct_mean : bool, optional\n        Whether to correct sea level measurements to a standardised mean\n        sea level by subtracting the mean of all observed sea level\n        observations. This can be useful when GESLA tide heights come\n        from different or unknown tide datums. Note: the observed mean\n        sea level calculated here may differ from true long-term/\n        astronomical Mean Sea Level (MSL) datum.\n    filter_use_flag : bool, optional\n        Whether to filter out low quality observations with a \"use_flag\"\n        value of 0 (do not use). Defaults to True.\n    site_metadata : bool, optional\n        Whether to add tide gauge station metadata as additional columns\n        in the output DataFrame. Defaults to True.\n    data_path : str, optional\n        Path to the raw GESLA data files. Default is\n        `/gdata1/data/sea_level/gesla/`.\n    metadata_path : str, optional\n        Path to the GESLA station metadata file.\n        Default is `/gdata1/data/sea_level/GESLA3_ALL 2.csv`.\n\n    Returns\n    -------\n    pd.DataFrame\n        Processed GESLA data as a DataFrame with columns including:\n\n        - \"time\": Timestamps,\n        - \"sea_level\": Observed sea level (m),\n        - \"qc_flag\": Observed sea level QC flag,\n        - \"use_flag\": Use-in-analysis flag (1 = use, 0 = do not use),\n\n        ...and additional columns from station metadata.\n    \"\"\"\n    # Load tide gauge metadata\n    metadata_df, metadata_gdf = _load_gauge_metadata(metadata_path)\n\n    # Use supplied site codes if available\n    if site_code is not None:\n        site_code = [site_code] if not isinstance(site_code, list) else site_code\n\n    # If x and y are tuples, use xy bounds to identify sites\n    elif isinstance(x, (tuple, list)) &amp; isinstance(y, (tuple, list)):\n        bbox = BoundingBox.from_xy(x, y)\n        site_code = metadata_gdf.cx[bbox.left : bbox.right, bbox.top : bbox.bottom].index\n\n    # If x and y are single numbers, select nearest row\n    elif isinstance(x, Number) &amp; isinstance(y, Number):\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\")\n            site_code = (\n                _nearest_row(metadata_gdf, x, y, max_distance).rename({\"index_right\": \"site_code\"}, axis=1).site_code\n            )\n            # site_code = _nearest_row(metadata_gdf, x, y, max_distance).site_code\n\n        # Raise exception if no valid tide gauges are found\n        if site_code.isnull().all():\n            raise Exception(f\"No tide gauge found within {max_distance} degrees of {x}, {y}.\")\n\n    # Otherwise if all are None, return all available site codes\n    elif (site_code is None) &amp; (x is None) &amp; (y is None):\n        site_code = metadata_df.index.to_list()\n\n    else:\n        raise TypeError(\n            \"`x` and `y` must be provided as either singular coordinates (e.g. `x=150`), or as a tuple bounding box (e.g. `x=(150, 152)`).\"\n        )\n\n    # Prepare times\n    if time is None:\n        time = [\"1800\", str(datetime.datetime.now().year)]\n    time = [time] if not isinstance(time, (list, tuple)) else time\n    start_time = _round_date_strings(time[0], round_type=\"start\")\n    end_time = _round_date_strings(time[-1], round_type=\"end\")\n\n    # Identify paths to load and nodata values for each site\n    metadata_df[\"file_name\"] = data_path + metadata_df[\"file_name\"]\n    paths_na = metadata_df.loc[site_code, [\"file_name\", \"null_value\"]]\n\n    # Load and combine into a single dataframe\n    gauge_list = [\n        _load_gesla_dataset(s, p, na_value=na)\n        for s, p, na in tqdm.tqdm(paths_na.itertuples(), total=len(paths_na), desc=\"Loading GESLA gauges\")\n    ]\n    data_df = pd.concat(gauge_list).sort_index().loc[slice(start_time, end_time)].reset_index().set_index(\"site_code\")\n\n    # Optionally filter by use flag column\n    if filter_use_flag:\n        data_df = data_df.loc[data_df.use_flag == 1]\n\n    # Optionally insert metadata into dataframe\n    if site_metadata:\n        data_df[metadata_df.columns] = metadata_df.loc[site_code]\n\n    # Add time to index and remove duplicates\n    data_df = data_df.set_index(\"time\", append=True)\n    duplicates = data_df.index.duplicated()\n    if duplicates.sum() &gt; 0:\n        warnings.warn(\"Duplicate timestamps were removed.\")\n        data_df = data_df.loc[~duplicates]\n\n    # Remove observed mean sea level if requested\n    if correct_mean:\n        data_df[\"sea_level\"] = data_df[\"sea_level\"].sub(data_df.groupby(\"site_code\")[\"sea_level\"].transform(\"mean\"))\n\n    # Return data\n    return data_df\n</code></pre>"},{"location":"api/#eo_tides.validation.load_gauge_gesla(x)","title":"<code>x</code>","text":""},{"location":"api/#eo_tides.validation.load_gauge_gesla(y)","title":"<code>y</code>","text":""},{"location":"api/#eo_tides.validation.load_gauge_gesla(site_code)","title":"<code>site_code</code>","text":""},{"location":"api/#eo_tides.validation.load_gauge_gesla(time)","title":"<code>time</code>","text":""},{"location":"api/#eo_tides.validation.load_gauge_gesla(max_distance)","title":"<code>max_distance</code>","text":""},{"location":"api/#eo_tides.validation.load_gauge_gesla(correct_mean)","title":"<code>correct_mean</code>","text":""},{"location":"api/#eo_tides.validation.load_gauge_gesla(filter_use_flag)","title":"<code>filter_use_flag</code>","text":""},{"location":"api/#eo_tides.validation.load_gauge_gesla(site_metadata)","title":"<code>site_metadata</code>","text":""},{"location":"api/#eo_tides.validation.load_gauge_gesla(data_path)","title":"<code>data_path</code>","text":""},{"location":"api/#eo_tides.validation.load_gauge_gesla(metadata_path)","title":"<code>metadata_path</code>","text":""},{"location":"api/#eo_tides.utils","title":"eo_tides.utils","text":"<p>Functions:</p> Name Description <code>clip_models</code> <p>Clip NetCDF-format ocean tide models to a bounding box.</p> <code>idw</code> <p>Perform Inverse Distance Weighting (IDW) interpolation.</p> <code>list_models</code> <p>List all tide models available for tide modelling.</p>"},{"location":"api/#eo_tides.utils.clip_models","title":"clip_models","text":"<pre><code>clip_models(\n    input_directory,\n    output_directory,\n    bbox,\n    model=None,\n    buffer=5,\n    overwrite=False,\n)\n</code></pre> <p>Clip NetCDF-format ocean tide models to a bounding box.</p> <p>This function identifies all NetCDF-format tide models in a given input directory, including \"ATLAS-netcdf\" (e.g. TPXO9-atlas-nc), \"FES-netcdf\" (e.g. FES2022, EOT20), and \"GOT-netcdf\" (e.g. GOT5.5) format files. Files for each model are then clipped to the extent of the provided bounding box, handling model-specific file structures. After each model is clipped, the result is exported to the output directory and verified with <code>pyTMD</code> to ensure the clipped data is suitable for tide modelling.</p> <p>For instructions on accessing and downloading tide models, see: https://geoscienceaustralia.github.io/eo-tides/setup/</p> <p>Parameters:</p> Name Type Description Default <code>str or PathLike</code> <p>Path to directory containing input NetCDF-format tide model files.</p> required <code>str or PathLike</code> <p>Path to directory where clipped NetCDF files will be exported.</p> required <code>tuple of float</code> <p>Bounding box for clipping the tide models in EPSG:4326 degrees coordinates, specified as <code>(left, bottom, right, top)</code>.</p> required <code>str or list of str</code> <p>The tide model (or models) to clip. Defaults to None, which will automatically identify and clip all NetCDF-format models in the input directly.</p> <code>None</code> <code>float</code> <p>Buffer distance (in degrees) added to the bounding box to provide sufficient data on edges of study area. Defaults to 5 degrees.</p> <code>5</code> <code>bool</code> <p>If True, overwrite existing files in the output directory. Defaults to False.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; clip_models(\n...     input_directory=\"tide_models/\",\n...     output_directory=\"tide_models_clipped/\",\n...     bbox=(-8.968392, 50.070574, 2.447160, 59.367122),\n... )\n</code></pre> Source code in <code>eo_tides/utils.py</code> <pre><code>def clip_models(\n    input_directory: str | os.PathLike,\n    output_directory: str | os.PathLike,\n    bbox: tuple[float, float, float, float],\n    model: list | None = None,\n    buffer: float = 5,\n    overwrite: bool = False,\n):\n    \"\"\"\n    Clip NetCDF-format ocean tide models to a bounding box.\n\n    This function identifies all NetCDF-format tide models in a\n    given input directory, including \"ATLAS-netcdf\" (e.g. TPXO9-atlas-nc),\n    \"FES-netcdf\" (e.g. FES2022, EOT20), and \"GOT-netcdf\" (e.g. GOT5.5)\n    format files. Files for each model are then clipped to the extent of\n    the provided bounding box, handling model-specific file structures.\n    After each model is clipped, the result is exported to the output\n    directory and verified with `pyTMD` to ensure the clipped data is\n    suitable for tide modelling.\n\n    For instructions on accessing and downloading tide models, see:\n    &lt;https://geoscienceaustralia.github.io/eo-tides/setup/&gt;\n\n    Parameters\n    ----------\n    input_directory : str or os.PathLike\n        Path to directory containing input NetCDF-format tide model files.\n    output_directory : str or os.PathLike\n        Path to directory where clipped NetCDF files will be exported.\n    bbox : tuple of float\n        Bounding box for clipping the tide models in EPSG:4326 degrees\n        coordinates, specified as `(left, bottom, right, top)`.\n    model : str or list of str, optional\n        The tide model (or models) to clip. Defaults to None, which\n        will automatically identify and clip all NetCDF-format models\n        in the input directly.\n    buffer : float, optional\n        Buffer distance (in degrees) added to the bounding box to provide\n        sufficient data on edges of study area. Defaults to 5 degrees.\n    overwrite : bool, optional\n        If True, overwrite existing files in the output directory.\n        Defaults to False.\n\n    Examples\n    --------\n    &gt;&gt;&gt; clip_models(\n    ...     input_directory=\"tide_models/\",\n    ...     output_directory=\"tide_models_clipped/\",\n    ...     bbox=(-8.968392, 50.070574, 2.447160, 59.367122),\n    ... )\n    \"\"\"\n\n    # Get input and output paths\n    input_directory = _set_directory(input_directory)\n    output_directory = pathlib.Path(output_directory)\n\n    # Prepare bounding box\n    bbox = odc.geo.geom.BoundingBox(*bbox, crs=\"EPSG:4326\").buffered(buffer)\n\n    # Identify NetCDF models\n    model_database = load_database()[\"elevation\"]\n    netcdf_formats = [\"ATLAS-netcdf\", \"FES-netcdf\", \"GOT-netcdf\"]\n    netcdf_models = {k for k, v in model_database.items() if v[\"format\"] in netcdf_formats}\n\n    # Identify subset of available and requested NetCDF models\n    available_models, _ = list_models(directory=input_directory, show_available=False, show_supported=False)\n    requested_models = list(np.atleast_1d(model)) if model is not None else available_models\n    available_netcdf_models = list(set(available_models) &amp; set(requested_models) &amp; set(netcdf_models))\n\n    # Raise error if no valid models found\n    if len(available_netcdf_models) == 0:\n        raise ValueError(f\"No valid NetCDF models found in {input_directory}.\")\n\n    # If model list is provided,\n    print(f\"Preparing to clip suitable NetCDF models: {available_netcdf_models}\\n\")\n\n    # Loop through suitable models and export\n    for m in available_netcdf_models:\n        # Get model file and grid file list if they exist\n        model_files = model_database[m].get(\"model_file\", [])\n        grid_file = model_database[m].get(\"grid_file\", [])\n\n        # Convert to list if strings and combine\n        model_files = model_files if isinstance(model_files, list) else [model_files]\n        grid_file = grid_file if isinstance(grid_file, list) else [grid_file]\n        all_files = model_files + grid_file\n\n        # Loop through each model file and clip\n        for file in tqdm(all_files, desc=f\"Clipping {m}\"):\n            # Skip if it exists in output directory\n            if (output_directory / file).exists() and not overwrite:\n                continue\n\n            # Load model file\n            nc = xr.open_mfdataset(input_directory / file)\n\n            # Open file and clip according to model\n            if m in (\n                \"GOT5.5\",\n                \"GOT5.5_load\",\n                \"GOT5.5_extrapolated\",\n                \"GOT5.5D\",\n                \"GOT5.5D_extrapolated\",\n                \"GOT5.6\",\n                \"GOT5.6_extrapolated\",\n            ):\n                nc_clipped = _clip_model_file(\n                    nc,\n                    bbox,\n                    xdim=\"lon\",\n                    ydim=\"lat\",\n                    ycoord=\"latitude\",\n                    xcoord=\"longitude\",\n                )\n\n            elif m in (\"HAMTIDE11\",):\n                nc_clipped = _clip_model_file(nc, bbox, xdim=\"LON\", ydim=\"LAT\", ycoord=\"LAT\", xcoord=\"LON\")\n\n            elif m in (\n                \"EOT20\",\n                \"EOT20_load\",\n                \"FES2012\",\n                \"FES2014\",\n                \"FES2014_extrapolated\",\n                \"FES2014_load\",\n                \"FES2022\",\n                \"FES2022_extrapolated\",\n                \"FES2022_load\",\n            ):\n                nc_clipped = _clip_model_file(nc, bbox, xdim=\"lon\", ydim=\"lat\", ycoord=\"lat\", xcoord=\"lon\")\n\n            elif m in (\n                \"TPXO8-atlas-nc\",\n                \"TPXO9-atlas-nc\",\n                \"TPXO9-atlas-v2-nc\",\n                \"TPXO9-atlas-v3-nc\",\n                \"TPXO9-atlas-v4-nc\",\n                \"TPXO9-atlas-v5-nc\",\n                \"TPXO10-atlas-v2-nc\",\n            ):\n                nc_clipped = _clip_model_file(\n                    nc,\n                    bbox,\n                    xdim=\"nx\",\n                    ydim=\"ny\",\n                    ycoord=\"lat_z\",\n                    xcoord=\"lon_z\",\n                )\n\n            else:\n                raise Exception(f\"Model {m} not supported\")\n\n            # Create directory and export\n            (output_directory / file).parent.mkdir(parents=True, exist_ok=True)\n            nc_clipped.to_netcdf(output_directory / file, mode=\"w\")\n\n        # Verify that models are ready\n        pytmd_model(directory=output_directory).elevation(m=m).verify\n        print(\" \u2705 Clipped model exported and verified\")\n\n    print(f\"\\nOutputs exported to {output_directory}\")\n    list_models(directory=output_directory, show_available=True, show_supported=False)\n</code></pre>"},{"location":"api/#eo_tides.utils.clip_models(input_directory)","title":"<code>input_directory</code>","text":""},{"location":"api/#eo_tides.utils.clip_models(output_directory)","title":"<code>output_directory</code>","text":""},{"location":"api/#eo_tides.utils.clip_models(bbox)","title":"<code>bbox</code>","text":""},{"location":"api/#eo_tides.utils.clip_models(model)","title":"<code>model</code>","text":""},{"location":"api/#eo_tides.utils.clip_models(buffer)","title":"<code>buffer</code>","text":""},{"location":"api/#eo_tides.utils.clip_models(overwrite)","title":"<code>overwrite</code>","text":""},{"location":"api/#eo_tides.utils.idw","title":"idw","text":"<pre><code>idw(\n    input_z,\n    input_x,\n    input_y,\n    output_x,\n    output_y,\n    p=1,\n    k=10,\n    max_dist=None,\n    k_min=1,\n    epsilon=1e-12,\n)\n</code></pre> <p>Perform Inverse Distance Weighting (IDW) interpolation.</p> <p>This function performs fast IDW interpolation by creating a KDTree from the input coordinates then uses it to find the <code>k</code> nearest neighbors for each output point. Weights are calculated based on the inverse distance to each neighbor, with weights descreasing with increasing distance.</p> <p>Code inspired by: https://github.com/DahnJ/REM-xarray</p> <p>Parameters:</p> Name Type Description Default <code>array - like</code> <p>Array of values at the input points. This can be either a 1-dimensional array, or a 2-dimensional array where each column (axis=1) represents a different set of values to be interpolated.</p> required <code>array - like</code> <p>Array of x-coordinates of the input points.</p> required <code>array - like</code> <p>Array of y-coordinates of the input points.</p> required <code>array - like</code> <p>Array of x-coordinates where the interpolation is to be computed.</p> required <code>array - like</code> <p>Array of y-coordinates where the interpolation is to be computed.</p> required <code>int or float</code> <p>Power function parameter defining how rapidly weightings should decrease as distance increases. Higher values of <code>p</code> will cause weights for distant points to decrease rapidly, resulting in nearby points having more influence on predictions. Defaults to 1.</p> <code>1</code> <code>int</code> <p>Number of nearest neighbors to use for interpolation. <code>k=1</code> is equivalent to \"nearest\" neighbour interpolation. Defaults to 10.</p> <code>10</code> <code>int or float</code> <p>Restrict neighbouring points to less than this distance. By default, no distance limit is applied.</p> <code>None</code> <code>int</code> <p>If <code>max_dist</code> is provided, some points may end up with less than <code>k</code> nearest neighbours, potentially producing less reliable interpolations. Set <code>k_min</code> to set any points with less than <code>k_min</code> neighbours to NaN. Defaults to 1.</p> <code>1</code> <code>float</code> <p>Small value added to distances to prevent division by zero errors in the case that output coordinates are identical to input coordinates. Defaults to 1e-12.</p> <code>1e-12</code> <p>Returns:</p> Name Type Description <code>interp_values</code> <code>ndarray</code> <p>Interpolated values at the output coordinates. If <code>input_z</code> is 1-dimensional, <code>interp_values</code> will also be 1-dimensional. If <code>input_z</code> is 2-dimensional, <code>interp_values</code> will have the same number of rows as <code>input_z</code>, with each column (axis=1) representing interpolated values for one set of input data.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; input_z = [1, 2, 3, 4, 5]\n&gt;&gt;&gt; input_x = [0, 1, 2, 3, 4]\n&gt;&gt;&gt; input_y = [0, 1, 2, 3, 4]\n&gt;&gt;&gt; output_x = [0.5, 1.5, 2.5]\n&gt;&gt;&gt; output_y = [0.5, 1.5, 2.5]\n&gt;&gt;&gt; idw(input_z, input_x, input_y, output_x, output_y, k=2)\narray([1.5, 2.5, 3.5])\n</code></pre> Source code in <code>eo_tides/utils.py</code> <pre><code>def idw(\n    input_z,\n    input_x,\n    input_y,\n    output_x,\n    output_y,\n    p=1,\n    k=10,\n    max_dist=None,\n    k_min=1,\n    epsilon=1e-12,\n):\n    \"\"\"Perform Inverse Distance Weighting (IDW) interpolation.\n\n    This function performs fast IDW interpolation by creating a KDTree\n    from the input coordinates then uses it to find the `k` nearest\n    neighbors for each output point. Weights are calculated based on the\n    inverse distance to each neighbor, with weights descreasing with\n    increasing distance.\n\n    Code inspired by: &lt;https://github.com/DahnJ/REM-xarray&gt;\n\n    Parameters\n    ----------\n    input_z : array-like\n        Array of values at the input points. This can be either a\n        1-dimensional array, or a 2-dimensional array where each column\n        (axis=1) represents a different set of values to be interpolated.\n    input_x : array-like\n        Array of x-coordinates of the input points.\n    input_y : array-like\n        Array of y-coordinates of the input points.\n    output_x : array-like\n        Array of x-coordinates where the interpolation is to be computed.\n    output_y : array-like\n        Array of y-coordinates where the interpolation is to be computed.\n    p : int or float, optional\n        Power function parameter defining how rapidly weightings should\n        decrease as distance increases. Higher values of `p` will cause\n        weights for distant points to decrease rapidly, resulting in\n        nearby points having more influence on predictions. Defaults to 1.\n    k : int, optional\n        Number of nearest neighbors to use for interpolation. `k=1` is\n        equivalent to \"nearest\" neighbour interpolation. Defaults to 10.\n    max_dist : int or float, optional\n        Restrict neighbouring points to less than this distance.\n        By default, no distance limit is applied.\n    k_min : int, optional\n        If `max_dist` is provided, some points may end up with less than\n        `k` nearest neighbours, potentially producing less reliable\n        interpolations. Set `k_min` to set any points with less than\n        `k_min` neighbours to NaN. Defaults to 1.\n    epsilon : float, optional\n        Small value added to distances to prevent division by zero\n        errors in the case that output coordinates are identical to\n        input coordinates. Defaults to 1e-12.\n\n    Returns\n    -------\n    interp_values : numpy.ndarray\n        Interpolated values at the output coordinates. If `input_z` is\n        1-dimensional, `interp_values` will also be 1-dimensional. If\n        `input_z` is 2-dimensional, `interp_values` will have the same\n        number of rows as `input_z`, with each column (axis=1)\n        representing interpolated values for one set of input data.\n\n    Examples\n    --------\n    &gt;&gt;&gt; input_z = [1, 2, 3, 4, 5]\n    &gt;&gt;&gt; input_x = [0, 1, 2, 3, 4]\n    &gt;&gt;&gt; input_y = [0, 1, 2, 3, 4]\n    &gt;&gt;&gt; output_x = [0.5, 1.5, 2.5]\n    &gt;&gt;&gt; output_y = [0.5, 1.5, 2.5]\n    &gt;&gt;&gt; idw(input_z, input_x, input_y, output_x, output_y, k=2)\n    array([1.5, 2.5, 3.5])\n\n    \"\"\"\n    # Convert to numpy arrays\n    input_x = np.atleast_1d(input_x)\n    input_y = np.atleast_1d(input_y)\n    input_z = np.atleast_1d(input_z)\n    output_x = np.atleast_1d(output_x)\n    output_y = np.atleast_1d(output_y)\n\n    # Verify input and outputs have matching lengths\n    if not (input_z.shape[0] == len(input_x) == len(input_y)):\n        raise ValueError(\"All of `input_z`, `input_x` and `input_y` must be the same length.\")\n    if not (len(output_x) == len(output_y)):\n        raise ValueError(\"Both `output_x` and `output_y` must be the same length.\")\n\n    # Verify k is smaller than total number of points, and non-zero\n    if k &gt; input_z.shape[0]:\n        raise ValueError(\n            f\"The requested number of nearest neighbours (`k={k}`) \"\n            f\"is smaller than the total number of points ({input_z.shape[0]}).\",\n        )\n    if k == 0:\n        raise ValueError(\"Interpolation based on `k=0` nearest neighbours is not valid.\")\n\n    # Create KDTree to efficiently find nearest neighbours\n    points_xy = np.column_stack((input_y, input_x))\n    tree = KDTree(points_xy)\n\n    # Determine nearest neighbours and distances to each\n    grid_stacked = np.column_stack((output_y, output_x))\n    distances, indices = tree.query(grid_stacked, k=k, workers=-1)\n\n    # If k == 1, add an additional axis for consistency\n    if k == 1:\n        distances = distances[..., np.newaxis]\n        indices = indices[..., np.newaxis]\n\n    # Add small epsilon to distances to prevent division by zero errors\n    # if output coordinates are the same as input coordinates\n    distances = np.maximum(distances, epsilon)\n\n    # Set distances above max to NaN if specified\n    if max_dist is not None:\n        distances[distances &gt; max_dist] = np.nan\n\n    # Calculate weights based on distance to k nearest neighbours.\n    weights = 1 / np.power(distances, p)\n    weights = weights / np.nansum(weights, axis=1).reshape(-1, 1)\n\n    # 1D case: Compute weighted sum of input_z values for each output point\n    if input_z.ndim == 1:\n        interp_values = np.nansum(weights * input_z[indices], axis=1)\n\n    # 2D case: Compute weighted sum for each set of input_z values\n    # weights[..., np.newaxis] adds a dimension for broadcasting\n    else:\n        interp_values = np.nansum(\n            weights[..., np.newaxis] * input_z[indices],\n            axis=1,\n        )\n\n    # Set any points with less than `k_min` valid weights to NaN\n    interp_values[np.isfinite(weights).sum(axis=1) &lt; k_min] = np.nan\n\n    return interp_values\n</code></pre>"},{"location":"api/#eo_tides.utils.idw(input_z)","title":"<code>input_z</code>","text":""},{"location":"api/#eo_tides.utils.idw(input_x)","title":"<code>input_x</code>","text":""},{"location":"api/#eo_tides.utils.idw(input_y)","title":"<code>input_y</code>","text":""},{"location":"api/#eo_tides.utils.idw(output_x)","title":"<code>output_x</code>","text":""},{"location":"api/#eo_tides.utils.idw(output_y)","title":"<code>output_y</code>","text":""},{"location":"api/#eo_tides.utils.idw(p)","title":"<code>p</code>","text":""},{"location":"api/#eo_tides.utils.idw(k)","title":"<code>k</code>","text":""},{"location":"api/#eo_tides.utils.idw(max_dist)","title":"<code>max_dist</code>","text":""},{"location":"api/#eo_tides.utils.idw(k_min)","title":"<code>k_min</code>","text":""},{"location":"api/#eo_tides.utils.idw(epsilon)","title":"<code>epsilon</code>","text":""},{"location":"api/#eo_tides.utils.list_models","title":"list_models","text":"<pre><code>list_models(\n    directory=None,\n    show_available=True,\n    show_supported=True,\n    raise_error=False,\n)\n</code></pre> <p>List all tide models available for tide modelling.</p> <p>This function scans the specified tide model directory and returns a list of models that are available in the directory as well as the full list of all models supported by <code>eo-tides</code> and <code>pyTMD</code>.</p> <p>For instructions on setting up tide models, see: https://geoscienceaustralia.github.io/eo-tides/setup/</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The directory containing tide model data files. If no path is provided, this will default to the environment variable <code>EO_TIDES_TIDE_MODELS</code> if set, or raise an error if not. Tide modelling files should be stored in sub-folders for each model that match the structure required by <code>pyTMD</code> (https://geoscienceaustralia.github.io/eo-tides/setup/).</p> <code>None</code> <code>bool</code> <p>Whether to print a list of locally available models.</p> <code>True</code> <code>bool</code> <p>Whether to print a list of all supported models, in addition to models available locally.</p> <code>True</code> <code>bool</code> <p>If True, raise an error if no available models are found. If False, raise a warning.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>available_models</code> <code>list of str</code> <p>A list of all tide models available within <code>directory</code>.</p> <code>supported_models</code> <code>list of str</code> <p>A list of all tide models supported by <code>eo-tides</code>.</p> Source code in <code>eo_tides/utils.py</code> <pre><code>def list_models(\n    directory: str | os.PathLike | None = None,\n    show_available: bool = True,\n    show_supported: bool = True,\n    raise_error: bool = False,\n) -&gt; tuple[list[str], list[str]]:\n    \"\"\"\n    List all tide models available for tide modelling.\n\n    This function scans the specified tide model directory\n    and returns a list of models that are available in the\n    directory as well as the full list of all models supported\n    by `eo-tides` and `pyTMD`.\n\n    For instructions on setting up tide models, see:\n    &lt;https://geoscienceaustralia.github.io/eo-tides/setup/&gt;\n\n    Parameters\n    ----------\n    directory : str, optional\n        The directory containing tide model data files. If no path is\n        provided, this will default to the environment variable\n        `EO_TIDES_TIDE_MODELS` if set, or raise an error if not.\n        Tide modelling files should be stored in sub-folders for each\n        model that match the structure required by `pyTMD`\n        (&lt;https://geoscienceaustralia.github.io/eo-tides/setup/&gt;).\n    show_available : bool, optional\n        Whether to print a list of locally available models.\n    show_supported : bool, optional\n        Whether to print a list of all supported models, in\n        addition to models available locally.\n    raise_error : bool, optional\n        If True, raise an error if no available models are found.\n        If False, raise a warning.\n\n    Returns\n    -------\n    available_models : list of str\n        A list of all tide models available within `directory`.\n    supported_models : list of str\n        A list of all tide models supported by `eo-tides`.\n    \"\"\"\n    init()  # Initialize colorama\n\n    # Set tide modelling files directory. If no custom path is\n    # provided, try global environment variable.\n    directory = _set_directory(directory)\n\n    # Get full list of supported models from pyTMD database\n    model_database = load_database()[\"elevation\"]\n    supported_models = list(model_database.keys())\n\n    # Extract expected model paths\n    expected_paths = {}\n    for m in supported_models:\n        model_file = model_database[m][\"model_file\"]\n\n        # Handle GOT5.6 differently to ensure we test for presence of GOT5.6 constituents\n        if m in (\"GOT5.6\", \"GOT5.6_extrapolated\"):\n            model_file = [file for file in model_file if \"GOT5.6\" in file][0]\n        else:\n            model_file = model_file[0] if isinstance(model_file, list) else model_file\n\n        # Add path to dict\n        expected_paths[m] = str(directory / pathlib.Path(model_file).expanduser().parent)\n\n    # Define column widths\n    status_width = 4  # Width for emoji\n    name_width = max(len(name) for name in supported_models)\n    path_width = max(len(path) for path in expected_paths.values())\n\n    # Print list of supported models, marking available and\n    # unavailable models and appending available to list\n    if show_available or show_supported:\n        total_width = min(status_width + name_width + path_width + 6, 80)\n        print(\"\u2500\" * total_width)\n        print(f\"{'\udb40\udc20\ud83c\udf0a':^{status_width}} | {'Model':&lt;{name_width}} | {'Expected path':&lt;{path_width}}\")\n        print(\"\u2500\" * total_width)\n\n    available_models = []\n    for m in supported_models:\n        try:\n            model_file = pytmd_model(directory=directory).elevation(m=m)\n            available_models.append(m)\n\n            if show_available:\n                # Mark available models with a green tick\n                status = \"\u2705\"\n                print(f\"{status:^{status_width}}\u2502 {m:&lt;{name_width}} \u2502 {expected_paths[m]:&lt;{path_width}}\")\n        except FileNotFoundError:\n            if show_supported:\n                # Mark unavailable models with a red cross\n                status = \"\u274c\"\n                print(\n                    f\"{status:^{status_width}}\u2502 {Style.DIM}{m:&lt;{name_width}} \u2502 {expected_paths[m]:&lt;{path_width}}{Style.RESET_ALL}\"\n                )\n\n    if show_available or show_supported:\n        print(\"\u2500\" * total_width)\n\n        # Print summary\n        print(f\"\\n{Style.BRIGHT}Summary:{Style.RESET_ALL}\")\n        print(f\"Available models: {len(available_models)}/{len(supported_models)}\")\n\n    # Raise error or warning if no models are available\n    if not available_models:\n        warning_msg = textwrap.dedent(\n            f\"\"\"\n            No valid tide models are available in `{directory}`.\n            Are you sure you have provided the correct `directory` path, or set the\n            `EO_TIDES_TIDE_MODELS` environment variable to point to the location of your\n            tide model directory?\n            \"\"\"\n        ).strip()\n\n        if raise_error:\n            raise Exception(warning_msg)\n        else:\n            warnings.warn(warning_msg, UserWarning)\n\n    # Return list of available and supported models\n    return available_models, supported_models\n</code></pre>"},{"location":"api/#eo_tides.utils.list_models(directory)","title":"<code>directory</code>","text":""},{"location":"api/#eo_tides.utils.list_models(show_available)","title":"<code>show_available</code>","text":""},{"location":"api/#eo_tides.utils.list_models(show_supported)","title":"<code>show_supported</code>","text":""},{"location":"api/#eo_tides.utils.list_models(raise_error)","title":"<code>raise_error</code>","text":""},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v050","title":"v0.5.0","text":""},{"location":"changelog/#new-features","title":"New features","text":"<ul> <li>Added draft version of a Journal of Open Source Software paper</li> <li>Added benchmarking notebook that compares performance with parallelisation on and off</li> </ul>"},{"location":"changelog/#bug-fixes","title":"Bug fixes","text":"<ul> <li>Fix documentation to point to correct location of <code>list_models</code> function (e.g. <code>eo_tides.utils.list_models</code>)</li> </ul>"},{"location":"changelog/#breaking-changes","title":"Breaking changes","text":"<ul> <li>Removed Python 3.9 support</li> <li>Added Python 3.13 support</li> </ul>"},{"location":"changelog/#v040","title":"v0.4.0","text":""},{"location":"changelog/#new-features_1","title":"New features","text":"<ul> <li> <p>Publishes ensemble tide modelling code for combining multiple global ocean tide models into a single locally optimised ensemble tide model using external model ranking data (e.g. satellite altimetry or NDWI-tide correlations along the coastline).</p> </li> <li> <p>Update ensemble code to latest version that includes FES2022, GOT5.6 and TPXO10 tide models</p> </li> <li>Make ensemble model calculation function a top level function (i.e. rename from <code>_ensemble_model</code> to <code>ensemble_tides</code>)</li> <li> <p>Load tide model ranking points from external <code>flatgeobuf</code> format file for faster cloud access</p> </li> <li> <p>Major refactor to statistics functions to standardise code across both <code>pixel_stats</code> and <code>tide_stats</code> and add support for multiple models</p> </li> <li> <p><code>tide_stats</code> will now return a <code>pandas.Series</code> if one model is requested, and a <code>pandas.DataFrame</code> if multiple are requested</p> </li> <li> <p>Added a new <code>point_col</code> parameter to <code>tide_stats</code> to control the colour of plotted points. If <code>plot_var</code> is also provided, points will now be coloured differently by default.</p> </li> <li> <p>Added a new <code>crop_buffer</code> parameter to configure buffer distance when cropping model files with <code>crop=True</code> (defaults to 5 degrees)</p> </li> <li>Reorder <code>model_tides</code> parameters to provide more logical flow and move more common params like <code>mode</code>, <code>output_format</code> and <code>output_units</code> higher</li> </ul>"},{"location":"changelog/#bug-fixes_1","title":"Bug fixes","text":"<ul> <li>Fix warnings from <code>load_gauge_gesla</code> function</li> </ul>"},{"location":"changelog/#breaking-changes_1","title":"Breaking changes","text":"<ul> <li>The <code>plot_col</code> parameter from <code>tide_stats</code> has been renamed to <code>plot_var</code></li> </ul>"},{"location":"changelog/#v031-2024-11-15","title":"v0.3.1 (2024-11-15)","text":""},{"location":"changelog/#new-features_2","title":"New features","text":"<ul> <li>Add new \"all\" option to <code>model</code> param in <code>model_tides</code>, <code>pixel_tides</code> etc, which will model tides using all available tide models in your provided <code>directory</code>.</li> </ul>"},{"location":"changelog/#bug-fixes_2","title":"Bug fixes","text":"<ul> <li>Fix bug where GOT5.6 was not detected as a valid model because it contains files in multiple directories (e.g. both \"GOT5.6\" and \"GOT5.5\"). This also affected clipping GOT5.6 data using the <code>eo_tides.utils.clip_models</code> function.</li> </ul>"},{"location":"changelog/#v030-2024-11-11","title":"v0.3.0 (2024-11-11)","text":""},{"location":"changelog/#new-features_3","title":"New features","text":"<ul> <li>Added new <code>eo_tides.utils.clip_models</code> function for clipping tide models to a smaller spatial extent. This can have a major positive impact on performance, sometimes producing more than a 10 x speedup. This function identifies all NetCDF-format tide models in a given input directory, including \"ATLAS-netcdf\" (e.g. <code>TPXO9-atlas-nc</code>), \"FES-netcdf\" (e.g. <code>FES2022</code>, <code>EOT20</code>), and \"GOT-netcdf\" (e.g. <code>GOT5.5</code>) format files. Files for each model are then clipped to the extent of the provided bounding box, handling model-specific file structures. After each model is clipped, the result is exported to the output directory and verified with <code>pyTMD</code> to ensure the clipped data is suitable for tide modelling.</li> </ul>"},{"location":"changelog/#major-changes","title":"Major changes","text":"<ul> <li>The <code>parallel_splits</code> parameter that controls the number of chunks data is broken into for parallel analysis has been refactored to use a new default of \"auto\". This now attempts to automatically determine a sensible value based on available CPU, number of points, and number of models being run. All CPUs will be used where possible, unless this will produce splits with less than 1000 points in each (which would increase overhead). Parallel splits will be reduced if multiple models are requested, as these are run in parallel too and will compete for the same resources.</li> <li>Changed the default interpolation <code>method</code> from \"spline\" to \"linear\". This appears to produce the same results, but works considerably faster.</li> <li>Updates to enable correct cropping, recently resolved in PyTMD 2.1.8</li> </ul>"},{"location":"changelog/#breaking-changes_2","title":"Breaking changes","text":"<ul> <li>The <code>list_models</code> function has been relocated to <code>eo_tides.utils</code> (from <code>eo_tides.model</code>)</li> </ul>"},{"location":"changelog/#v020-2024-10-30","title":"v0.2.0 (2024-10-30)","text":""},{"location":"changelog/#new-features_4","title":"New features","text":"<ul> <li>New <code>model_phases</code> function for calculating tidal phases (\"low-flow\", high-flow\", \"high-ebb\", \"low-ebb\") for each tide height in a timeseries. Ebb and low phases are calculated by running the <code>eo_tides.model.model_tides</code> function twice, once for the requested timesteps, and again after subtracting a small time offset (by default, 15 minutes). If tides increased over this period, they are assigned as \"flow\"; if they decreased, they are assigned as \"ebb\". Tides are considered \"high\" if equal or greater than 0 metres tide height, otherwise \"low\".</li> <li>Major refactor to use consistent input parameters across all EO focused functions: input can now be either <code>xr.DataArray</code> or <code>xr.Dataset</code> or <code>odc.geo.geobox.GeoBox</code>; if an xarray object is passed, it must have a <code>\"time\"</code> dimension; if GeoBox is passed, time must be provided by the <code>time</code> parameter.</li> <li><code>time</code> parameters now accept any format that can be converted by <code>pandas.to_datetime()</code>; e.g. np.ndarray[datetime64], pd.DatetimeIndex, pd.Timestamp, datetime.datetime and strings (e.g. \"2020-01-01 23:00\").</li> <li><code>model_tides</code> now uses default cropping approach from <code>pyTMD</code>, rather than applying a bespoke 1 degree buffer around the selected analysis area</li> <li><code>model_tides</code> refactored to use simpler approach to loading tide consistuents enabled in <code>pyTMD==2.1.7</code></li> </ul>"},{"location":"changelog/#breaking-changes_3","title":"Breaking changes","text":"<ul> <li>The <code>ds</code> param in all satellite data functions (<code>tag_tides</code>, <code>pixel_tides</code>, <code>tide_stats</code>, <code>pixel_tides</code>) has been renamed to a more generic name <code>data</code> (to account for now accepting either <code>xarray.Dataset</code>, <code>xarray.DataArray</code> or a <code>odc.geo.geobox.GeoBox</code> inputs).</li> </ul>"},{"location":"changelog/#v010-2024-10-18","title":"v0.1.0 (2024-10-18)","text":""},{"location":"changelog/#new-features_5","title":"New features","text":"<ul> <li>Initial creation of <code>eo-tides</code> repo</li> </ul>"},{"location":"changelog/#breaking-changes_4","title":"Breaking changes","text":"<p>See Migrating from DEA Tools for a guide to updating your code from the original <code>Digital Earth Australia Notebooks and Tools</code> repository.</p>"},{"location":"credits/","title":"Citations and credits","text":""},{"location":"credits/#citing-eo-tides","title":"Citing <code>eo-tides</code>","text":"<p>To cite <code>eo-tides</code> in your work, please use the following software citation:</p> <pre><code>Bishop-Taylor, R., Sagar, S., Phillips, C., &amp; Newey, V. (2024). eo-tides: Tide modelling tools for large-scale satellite earth observation analysis. https://github.com/GeoscienceAustralia/eo-tides\n</code></pre> <p>In addition, please consider also citing the underlying <code>pyTMD</code> Python package which powers the tide modelling functionality behind <code>eo-tides</code>:</p> <pre><code>Sutterley, T. C., Alley, K., Brunt, K., Howard, S., Padman, L., Siegfried, M. (2017) pyTMD: Python-based tidal prediction software. 10.5281/zenodo.5555395\n</code></pre>"},{"location":"credits/#credits","title":"Credits","text":"<p><code>eo-tides</code> builds on (and wouldn't be possible without!) fundamental tide modelling tools provided by <code>pyTMD</code>. The authors wish to thank Dr. Tyler Sutterley for his ongoing development and support of this incredible modelling tool.</p> <p>Functions from <code>eo-tides</code> were originally developed in the <code>Digital Earth Australia Notebooks and Tools</code> repository. The authors would like to thank all DEA Notebooks contributers and maintainers for their invaluable assistance with code review, feature suggestions and code edits.</p> <p>FES Finite Element Solution tide models were developed, validated by the CTOH/LEGOS, France and distributed by Aviso+: https://www.aviso.altimetry.fr/en/data/products/sea-surface-height-products/regional/x-track-sla/x-track-l2p-sla-version-2022.html</p> <p>This repository was initialised using the <code>cookiecutter-uv</code> package.</p>"},{"location":"credits/#references","title":"References","text":"<p> <p>Carrere et al., OSTST 2022: A new barotropic tide model for global ocean: FES2022, https://doi.org/10.24400/527896/a03-2022.3287</p> <p>Egbert, Gary D., and Svetlana Y. Erofeeva. \"Efficient inverse modeling of barotropic ocean tides.\" Journal of Atmospheric and Oceanic Technology 19.2 (2002): 183-204.</p> <p>Florent H. Lyard, Loren Carrere, Ergane Fouchet, Mathilde Cancet, David Greenberg, G\u00e9rald Dibarboure and Nicolas Picot: \u201cFES2022 a step towards a SWOT-compliant tidal correction\u201d, to be submitted to Ocean Sciences.</p> <p>Hart-Davis Michael, Piccioni Gaia, Dettmering Denise, Schwatke Christian, Passaro Marcello, Seitz Florian (2021). EOT20 - A global Empirical Ocean Tide model from multi-mission satellite altimetry. SEANOE. https://doi.org/10.17882/79489</p> <p>Hart-Davis Michael G., Piccioni Gaia, Dettmering Denise, Schwatke Christian, Passaro Marcello, Seitz Florian (2021). EOT20: a global ocean tide model from multi-mission satellite altimetry. Earth System Science Data, 13 (8), 3869-3884. https://doi.org/10.5194/essd-13-3869-2021</p> <p>Sutterley, T. C., Markus, T., Neumann, T. A., van den Broeke, M., van Wessem, J. M., and Ligtenberg, S. R. M.: Antarctic ice shelf thickness change from multimission lidar mapping, The Cryosphere, 13, 1801\u20131817, https://doi.org/10.5194/tc-13-1801-2019, 2019.</p> <p></p>"},{"location":"install/","title":"Installing <code>eo-tides</code>","text":""},{"location":"install/#stable-version","title":"Stable version","text":"<p>The latest stable release of <code>eo-tides</code> can be installed into your Python environment from PyPI using <code>pip</code>:</p> <pre><code>python3 -m pip install eo-tides\n</code></pre> <p>By default, only essential package dependencies are installed. To install all packages required for running the included Jupyter Notebook examples (including <code>odc-stac</code> and <code>pystac-client</code> for loading freely available satellite data), run:</p> <pre><code>python3 -m pip install eo-tides[notebooks]\n</code></pre>"},{"location":"install/#unstable-development-version","title":"Unstable development version","text":"<p>To install the latest unstable development version of <code>eo-tides</code> directly from Github, run:</p> <pre><code>python3 -m pip install git+https://github.com/GeoscienceAustralia/eo-tides.git\n</code></pre> <p>Important</p> <p>Unstable development versions of <code>eo-tides</code> may contain bugs and untested new features. Unless you need access to a specific unpublished feature, we recommend installing the latest stable version instead.</p>"},{"location":"install/#cloning-locally","title":"Cloning locally","text":"<p>To clone the <code>eo-tides</code> repository locally:</p> <pre><code>git clone https://github.com/GeoscienceAustralia/eo-tides.git\n</code></pre> <p>Navigate to the project directory and install in editable mode from your local copy of the repository:</p> <pre><code>cd eo-tides\npython3 -m pip install -e .\n</code></pre>"},{"location":"install/#next-steps","title":"Next steps","text":"<p>Once you have installed <code>eo-tides</code>, you will need to download and set up at least one tide model before you can model tides.</p>"},{"location":"migration/","title":"Migrating from <code>dea_tools</code>","text":"<p>The <code>eo-tides</code> package contains functions that were previously available in the <code>Digital Earth Australia Notebooks and Tools</code> repository. To migrate your code from DEA Tools to <code>eo-tides</code>, please be aware of the following breaking changes:</p>"},{"location":"migration/#breaking-changes","title":"Breaking changes","text":""},{"location":"migration/#tide_m-renamed-to-tide_height","title":"\"tide_m\" renamed to \"tide_height\"","text":"<p>The default output tide heights column generated by the <code>model_tides</code> function and the <code>xarray.DataArray</code> outputs generated by <code>tag_tides</code> and <code>pixel_tides</code> have been renamed from <code>tide_m</code> to <code>tide_height</code>. This more clearly describes the data, particularly when used in combination with <code>output_units=\"cm\"</code> or <code>output_units=\"mm\"</code> which returns tide heights in non-metre units.</p> <p>Action required</p> <p>Update any references of <code>tide_m</code> to <code>tide_height</code></p>"},{"location":"migration/#default-model-changed-to-eot20","title":"Default model changed to \"EOT20\"","text":"<p>The default tide model has been changed from \"FES2014\" to the open source \"EOT20\" Empirical Ocean Tide tide model (CC BY 4.0):</p> <p>Hart-Davis Michael, Piccioni Gaia, Dettmering Denise, Schwatke Christian, Passaro Marcello, Seitz Florian (2021). EOT20 - A global Empirical Ocean Tide model from multi-mission satellite altimetry. SEANOE. https://doi.org/10.17882/79489</p> <p>Note that this change in default is primarily due to the permissive license of this model; the choice of optimal model will vary by study area and application.</p> <p>Action required</p> <p>To use FES2014, set <code>model=\"FES2014\"</code> instead of leaving the default <code>model=None</code>.</p>"},{"location":"migration/#tidal_tag-renamed-to-tag_tides","title":"<code>tidal_tag</code> renamed to <code>tag_tides</code>","text":"<p>Renamed for consistency with <code>model_tides</code> and <code>pixel_tides</code>.</p> <p>Action required</p> <p>Update references to <code>tidal_tag</code> to <code>tag_tides</code>.</p>"},{"location":"migration/#ds-param-renamed-to-data-now-accepts-geobox","title":"<code>ds</code> param renamed to <code>data</code>, now accepts <code>GeoBox</code>","text":"<p>The <code>ds</code> param in all satellite data functions (<code>tag_tides</code>, <code>pixel_tides</code>, <code>tide_stats</code>, <code>pixel_tides</code>) has been updated to accept either <code>xarray.Dataset</code>, <code>xarray.DataArray</code> or a <code>odc.geo.geobox.GeoBox</code>. To account for this change, the <code>ds</code> param has been renamed to a more generic name <code>data</code>.</p> <p>Action required</p> <p>Update: <pre><code>tag_tides(ds=your_data)\n</code></pre> To: <pre><code>tag_tides(data=your_data)\n</code></pre></p>"},{"location":"migration/#times-param-renamed-to-time-accepts-any-format-supported-by-pandasto_datetime","title":"<code>times</code> param renamed to <code>time</code>, accepts any format supported by <code>pandas.to_datetime()</code>","text":"<p>The <code>times</code> parameter has been renamed to <code>time</code>, and updated to more flexibly accept any time format that can be converted by <code>pandas.to_datetime()</code>; e.g. <code>np.ndarray[datetime64]</code>, <code>pd.DatetimeIndex</code>, <code>pd.Timestamp</code>, <code>datetime.datetime</code> and strings (e.g. <code>\"2020-01-01 23:00\"</code>). For example: <code>time=pd.date_range(start=\"2000\", end=\"2001\", freq=\"5h\")</code>.</p> <p>Action required</p> <p>Update: <pre><code>model_tides(..., times=...)\n</code></pre> To: <pre><code>model_tides(..., time=...)\n</code></pre></p>"},{"location":"migration/#tag_tides-now-returns-an-array-instead-of-updating-data-in-place","title":"<code>tag_tides</code> now returns an array instead of updating data in-place","text":"<p>The <code>tag_tides</code> function now returns an <code>xarray.DataArray</code> output containing tide heights, rather than appending tide height data to the original input dataset in-place. This change provides better consistency with <code>pixel_tides</code>, which also returns an array of tide heights.</p> <p>Action required</p> <p>Update: <pre><code>data = tag_tides(data, ...)\n</code></pre> To: <pre><code>data[\"tide_height\"] = tag_tides(data, ...)\n</code></pre></p>"},{"location":"migration/#pixel_tides-only-returns-a-single-array","title":"<code>pixel_tides</code> only returns a single array","text":"<p>The <code>pixel_tides</code> function has been updated to only ever return a single array as an output: a high-resolution tide height array matching the resolution of the input <code>data</code> by default, and a low-resolution tide height array if <code>resample=False</code>.</p> <p>Action required</p> <p>Update code to handle a single tide height array output from <code>pixel_tides</code>, instead of a tuple of high-resolution and low-resolution modelled tide height arrays.</p>"},{"location":"migration/#tide-model-directory-environment-variable-updated","title":"Tide model directory environment variable updated","text":"<p>The <code>DEA_TOOLS_TIDE_MODELS</code> environmental variable has been renamed to <code>EO_TIDES_TIDE_MODELS</code>.</p> <p>Action required</p> <p>Set the <code>EO_TIDES_TIDE_MODELS</code> environment variable instead of <code>DEA_TOOLS_TIDE_MODELS</code>.</p>"},{"location":"migration/#error-raised-if-both-directory-parameter-and-environment-variable-are-missing","title":"Error raised if both <code>directory</code> parameter and environment variable are missing","text":"<p>Previously, tide modelling functions used a fall-back tide modelling directory (<code>/var/share/tide_models</code>) if both the <code>directory</code> parameter and the tide model directory environment variable were absent. This fall-back has been removed, and an error will now be raised if no tide model directory is specified.</p> <p>Action required</p> <p>Ensure that either the <code>directory</code> parameter or the <code>EO_TIDES_TIDE_MODELS</code> environment variable are provided.</p>"},{"location":"setup/","title":"Setting up tide models","text":"<p>Important</p> <p><code>eo-tides</code> provides tools for modelling tides using global ocean tide models but does not host or maintain the models themselves. Users are responsible for accessing, using, and citing ocean tide models in compliance with each model's licensing terms.</p> <p>Once you have installed <code>eo-tides</code>, we need to download and set up the external global ocean tide models required for <code>eo-tides</code> to work. The following documentation provides instructions for getting started with several common global ocean tide models.</p> <p>Tip</p> <p>Please refer to the <code>pyTMD</code> documentation for additional instructions covering all other supported tide models.</p>"},{"location":"setup/#setting-up-a-tide-model-directory","title":"Setting up a tide model directory","text":"<p>As a first step, we need to create a directory that will contain our tide model data. This directory will be accessed by all <code>eo-tides</code> functions. For example, we might want to store our tide models in a directory called <code>tide_models/</code>:</p> <pre><code>tide_models/\n</code></pre> <p>Tip</p> <p>This directory doesn't need to be called <code>tide_models</code>; use any name and/or location that is convenient to you and accessible from your Python environment. Please refer to the documentation below for further details on configuring <code>eo-tides</code> to use this directory.</p>"},{"location":"setup/#downloading-tide-model-data","title":"Downloading tide model data","text":"<p>Now we need to download some data from one or more models, and save this into our tide model directory. Follow the guides below for some of the most commonly used global ocean tide models:</p> EOT20 Empirical Ocean Tide model (default) FES2022 Finite Element Solution tide models FES2014 Finite Element Solution tide models GOT Global Ocean Tide models TPXO Global Tidal Models <p>Tip</p> <p>To allow you to improve tide modelling performance by clipping your tide model files (see below), we recommend downloading NetCDF-format versions of tide models wherever possible.</p>"},{"location":"setup/#eot20-empirical-ocean-tide-model-default","title":"EOT20 Empirical Ocean Tide model (default)","text":"<ol> <li>Visit EOT20 - A global Empirical Ocean Tide model from multi-mission satellite altimetry</li> <li> <p>Under <code>Data</code>, click <code>Download</code>:</p> <p></p> </li> <li> <p>Create a new directory inside your tide model directory called <code>EOT20/</code> to store the EOT20 model files.</p> </li> <li> <p>Extract the <code>85762.zip</code> and then <code>ocean_tides.zip</code> into this new directory. You should end up with the following directory structure containing the extracted NetCDF files:</p> <pre><code>tide_models/EOT20/ocean_tides/\n   |- 2N2_ocean_eot20.nc\n   |- ...\n   |- T2_ocean_eot20.nc\n</code></pre> </li> </ol>"},{"location":"setup/#fes2022-finite-element-solution-tide-models","title":"FES2022 Finite Element Solution tide models","text":"<ol> <li> <p>Register with AVISO+, and select <code>FES (Finite Element Solution - Oceanic Tides Heights)</code> from the <code>Licence Agreement and product selection</code> section:</p> <p></p> </li> <li> <p>Scroll to the bottom of the page and agree to the licence agreement. Your request will be sent for approval (this may take several days).</p> </li> <li>Once you are notified via email that your registration and access is approved, login to MY AVISO+.</li> <li> <p>Once logged in, select My products in the left-hand menu:</p> <p></p> </li> <li> <p><code>FES (Finite Element Solution - Oceanic Tides Heights)</code> should appear under <code>Your current subscriptions.</code> Right click on <code>Ftp</code>, and copy the FTP address.</p> <p></p> </li> <li> <p>Using an FTP client like FileZilla, log in to the FTP using your AVISO+ username and password:</p> <p></p> </li> <li> <p>Navigate to <code>/auxiliary/tide_model/</code>, and download the contents of one or more of the following directories:</p> <ul> <li><code>fes2022b/ocean_tide/</code></li> <li><code>fes2022b/ocean_tide_extrapolated/</code></li> </ul> <p>Tip</p> <p>The \"extrapolated\" version of FES models have been extended inland using a simple \"nearest\" extrapolation method to ensure data coverage across the entire coastal zone. This can be useful for ensuring you always return a modelled tide, but can also introduce uncertainty into your modelling (particularly in complex regions such as narrow peninsulas or inlets/embayments).</p> </li> <li> <p>Create new nested directories inside your tide model directory called <code>fes2022b/ocean_tide/</code> (if using standard model data) or <code>fes2022b/ocean_tide_extrapolated/</code> (if using extrapolated model data) to store the FES2022 model files.</p> </li> <li> <p>Extract your <code>...nc.xz</code> files into this directory (e.g. <code>tar -xf m2_fes2022.nc.xz</code>). You should end up with the following directory structure containing the extracted NetCDF files:</p> <p><pre><code>tide_models/fes2022b/ocean_tide/\n   |- 2n2_fes2022.nc\n   |- ...\n   |- t2_fes2022.nc\n</code></pre> Or: <pre><code>tide_models/fes2022b/ocean_tide_extrapolated/\n   |- 2n2_fes2022.nc\n   |- ...\n   |- t2_fes2022.nc\n</code></pre></p> </li> </ol>"},{"location":"setup/#fes2014-finite-element-solution-tide-models","title":"FES2014 Finite Element Solution tide models","text":"<ol> <li> <p>Register with AVISO+, and select <code>FES (Finite Element Solution - Oceanic Tides Heights)</code> from the <code>Licence Agreement and product selection</code> section:</p> <p></p> </li> <li> <p>Scroll to the bottom of the page and agree to the licence agreement. Your request will be sent for approval (this may take several days).</p> </li> <li>Once you are notified via email that your registration and access is approved, login to MY AVISO+.</li> <li> <p>Once logged in, select My products in the left-hand menu:</p> <p></p> </li> <li> <p><code>FES (Finite Element Solution - Oceanic Tides Heights)</code> should appear under <code>Your current subscriptions.</code> Right click on <code>Ftp</code>, and copy the FTP address.</p> <p></p> </li> <li> <p>Using an FTP client like FileZilla, log in to the FTP using your AVISO+ username and password:</p> <p></p> </li> <li> <p>Navigate to <code>/auxiliary/tide_model/</code>, and download the contents of one or more of the following directories:</p> <ul> <li><code>fes2014_elevations_and_load/fes2014b_elevations/</code></li> <li><code>fes2014_elevations_and_load/fes2014b_elevations_extrapolated/</code></li> </ul> <p>Tip</p> <p>The \"extrapolated\" version of FES have been extended inland using a simple \"nearest\" extrapolation method to ensure data coverage across the entire coastal zone. This can be useful for ensuring you always return a modelled tide, but can also introduce uncertainty into your modelling (particularly in complex regions such as narrow peninsulas or inlets/embayments).</p> </li> <li> <p>Create a new directory inside your tide model directory called <code>fes2014/</code> to store the FES2014 model files.</p> </li> <li> <p>Extract <code>ocean_tide.tar.xz</code> or <code>ocean_tide_extrapolated.tar.xz</code> into this directory (e.g. <code>tar -xf ocean_tide.tar.xz</code>). You should end up with the following directory structure containing the extracted NetCDF files:</p> <p><pre><code>tide_models/fes2014/ocean_tide/\n   |- 2n2.nc\n   |- ...\n   |- t2.nc\n</code></pre> Or: <pre><code>tide_models/fes2014/ocean_tide_extrapolated/\n   |- 2n2.nc\n   |- ...\n   |- t2.nc\n</code></pre></p> </li> </ol>"},{"location":"setup/#got-global-ocean-tide-models","title":"GOT Global Ocean Tide models","text":"<ol> <li>Visit Ocean tide models</li> <li> <p>Under <code>Short-period (diurnal/semidiurnal) tides</code>, click choose your desired GOT model:</p> <p></p> </li> <li> <p>Create a new directory inside your tide model directory called either <code>GOT4.7/</code>, <code>got4.8/</code>, <code>GOT4.10c/</code>, <code>GOT5.5/</code> or <code>GOT5.6/</code> to store the GOT model files.</p> </li> <li> <p>Extract your downloaded <code>.tar.gz</code> file into this new directory. You should end up with the following directory structure containing the extracted NetCDF files:</p> <p><pre><code>tide_models/GOT5.6/ocean_tides/\n   |- ...\n</code></pre> Or: <pre><code>tide_models/GOT5.5/ocean_tides/\n   |- ...\n</code></pre></p> <p>Important</p> <p>Note that GOT5.6 requires that both GOT5.6 and GOT5.5 model files are downloaded and extracted.</p> <p>Or: <pre><code>tide_models/GOT4.10c/grids_oceantide/\n   |- ...\n</code></pre> Or: <pre><code>tide_models/got4.8/grids_oceantide/\n   |- ...\n</code></pre> Or: <pre><code>tide_models/GOT4.7/grids_oceantide/\n   |- ...\n</code></pre></p> </li> </ol>"},{"location":"setup/#tpxo-global-tidal-models","title":"TPXO Global Tidal Models","text":"<ol> <li>Visit TPXO Registration</li> <li>Follow instructions to email TPXO authors for access, providing your name, institution, your intended application/use case, and which TPXO models you need (\"TPXO10-atlas-v2 netcdf\" or \"TPXO9-atlas-v5 netcdf\" are recommended to enable clipping).</li> <li> <p>If your request is approved, you will be emailed an invite to an app.box.com folder. Open this link, then click \"Download\" on the top-right to download your zipped model files.</p> <p></p> </li> <li> <p>Create a new directory inside your tide model directory called either <code>TPXO10_atlas_v2/</code> or <code>TPXO9_atlas_v5/</code> to store the TPXO model files.</p> </li> <li> <p>Extract your zipped model files (e.g. <code>TPXO10_atlas_v2_nc.zip</code> or <code>TPXO9_atlas_v5_nc.zip</code>) into this new directory. You should end up with the following directory structure containing the extracted NetCDF files depending on the model you downloaded:</p> <p><pre><code>tide_models/TPXO10_atlas_v2/\n   |- grid_tpxo10atlas_v2.nc\n   |- ...\n   |- u_s2_tpxo10_atlas_30_v2.nc\n</code></pre> Or: <pre><code>tide_models/TPXO9_atlas_v5/\n   |- grid_tpxo9_atlas_30_v5.nc\n   |- ...\n   |- u_s2_tpxo9_atlas_30_v5.nc\n</code></pre></p> </li> </ol>"},{"location":"setup/#configuring-eo-tides-to-use-tide-model-directory","title":"Configuring <code>eo-tides</code> to use tide model directory","text":"<p><code>eo-tides</code> can be pointed to the location of your tide model directory and your downloaded tide model data in two ways:</p>"},{"location":"setup/#1-using-the-directory-function-parameter","title":"1. Using the <code>directory</code> function parameter","text":"<p>All tide modelling functions from <code>eo-tides</code> provide a <code>directory</code> parameter that can be used to specify the location of your tide model directory. For example, using the <code>eo_tides.model.model_tides</code> function:</p> <pre><code>import pandas as pd\nfrom eo_tides.model import model_tides\n\nmodel_tides(\n        x=155,\n        y=-35,\n        time=pd.date_range(\"2022-01-01\", \"2022-01-04\", freq=\"1D\"),\n        directory=\"tide_models/\"\n)\n</code></pre>"},{"location":"setup/#2-advanced-setting-the-eo_tides_tide_models-environmental-variable","title":"2. (Advanced) Setting the <code>EO_TIDES_TIDE_MODELS</code> environmental variable","text":"<p>For more advanced usage, you can set the path to your tide model directory by setting the <code>EO_TIDES_TIDE_MODELS</code> environment variable:</p> <pre><code>import os\nos.environ[\"EO_TIDES_TIDE_MODELS\"] = \"tide_models/\"\n</code></pre> <p>All tide modelling functions from <code>eo-tides</code> will check for the presence of the <code>EO_TIDES_TIDE_MODELS</code> environment variable, and use it as the default <code>directory</code> path if available (the <code>EO_TIDES_TIDE_MODELS</code> environment variable will be overuled by the <code>directory</code> parameter if provided).</p> <p>Tip</p> <p>Setting the <code>EO_TIDES_TIDE_MODELS</code> environment variable can be useful when the location of your tide model directory might change between different environments, and you want to avoid hard-coding a single location via the <code>directory</code> parameter.</p>"},{"location":"setup/#verifying-available-and-supported-models","title":"Verifying available and supported models","text":"<p>You can check what tide models have been correctly set up for use by <code>eo-tides</code> using the <code>eo_tides.utils.list_models</code> function:</p> <pre><code>from eo_tides.utils import list_models\n\navailable_models, supported_models = list_models(directory=\"tide_models/\")\n</code></pre> <p>This will print out a useful summary, with available models marked with a \u2705:</p> <pre><code>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n \udb40\udc20\ud83c\udf0a  | Model        | Expected path\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n \u2705  \u2502 EOT20        \u2502 tide_models/EOT20/ocean_tides\n \u274c  \u2502 FES2014      \u2502 tide_models/fes2014/ocean_tide\n \u2705  \u2502 HAMTIDE11    \u2502 tide_models/hamtide\n \u274c  \u2502 TPXO9.1      \u2502 tide_models/TPXO9.1/DATA\n ...   ...            ...\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nSummary:\nAvailable models: 2/50\n</code></pre> <p>Tip</p> <p>If the models that you saved are not marked as available in this summary, check that they were saved to the expected path as identified in the summary table.</p>"},{"location":"setup/#clipping-model-files-to-improve-performance","title":"Clipping model files to improve performance","text":"<p>Highly recommended</p> <p>Clipping your model files to a smaller spatial extent is highly recommended, unless you are specifically running global-scale analyses.</p> <p>Running tide modelling on the default tide modelling data provided by external providers can be slow due to the large size of these files (especially for high-resolution models like FES2022). To improve performance, it can be extremely useful to clip your model files to a smaller region of interest (e.g. the extents of your country or coastal region). This can greatly improve run-times: potentially speeding up your tide modelling by over 10 times for large models!</p> <p>Once you have downloaded and verified your tide model data, you can use the <code>eo_tides.utils.clip_models</code> function to automatically clip your data, and export them to a new tide modelling directory:</p> <pre><code>from eo_tides.utils import clip_models\n\nclip_models(\n    input_directory=\"tide_models/\",\n    output_directory=\"tide_models_clipped/\",\n    bbox=(113.3, -43.6, 153.6, -10.7),\n)\n</code></pre> <p>When you run <code>clip_models</code>, the function will automatically identify suitable NetCDF-format models in your input directory, and clip each of them to the extent of your bounding box (specified as <code>(left, bottom, right, top)</code> in EPSG:4326 degree coordinates). After each model is clipped, the result is exported to your selected output directory and verified to ensure the clipped data is suitable for tide modelling:</p> <pre><code>Preparing to clip suitable NetCDF models: ['HAMTIDE11', 'EOT20']\n\nClipping HAMTIDE11: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 9/9 [00:03&lt;00:00,  2.60it/s]\n\u2705 Clipped model exported and verified\nClipping EOT20: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 17/17 [00:07&lt;00:00,  2.36it/s]\n\u2705 Clipped model exported and verified\n\nOutputs exported to tide_models_clipped/\n</code></pre> <p>You can now pass this new clipped tide model directory to all future <code>eo_tides</code> function calls for improved tide modelling performance, e.g.:</p> <pre><code>model_tides(\n        x=155,\n        y=-35,\n        time=pd.date_range(\"2022-01-01\", \"2022-01-04\", freq=\"1D\"),\n        directory=\"tide_models_clipped/\"\n)\n</code></pre> <p>Example of tide model data for the M2 tidal constituent from <code>EOT20</code> clipped to Australia:</p> <p></p> <p>Tip</p> <p>Because only NetCDF-format tide models can be clipped, we recommend downloading NetCDF versions of your tide models wherever possible.</p>"},{"location":"setup/#next-steps","title":"Next steps","text":"<p>Now that you have installed <code>eo-tides</code> and set up some tide models, you can learn how to use <code>eo-tides</code> for modelling tides and analysing satellite data!</p>"},{"location":"notebooks/Case_study_intertidal/","title":"Mapping the intertidal zone","text":"In\u00a0[1]: Copied! <pre>import odc.stac\nimport pystac_client\nimport planetary_computer\nimport matplotlib.pyplot as plt\n\nfrom eo_tides.eo import tag_tides\nfrom eo_tides.stats import tide_stats\nfrom eo_tides.utils import list_models\n</pre> import odc.stac import pystac_client import planetary_computer import matplotlib.pyplot as plt  from eo_tides.eo import tag_tides from eo_tides.stats import tide_stats from eo_tides.utils import list_models In\u00a0[2]: Copied! <pre>directory = \"../../tests/data/tide_models\"\n\n# Confirm we have model data\nlist_models(directory=directory, show_supported=False);\n</pre> directory = \"../../tests/data/tide_models\"  # Confirm we have model data list_models(directory=directory, show_supported=False); <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n \udb40\udc20\ud83c\udf0a  | Model                | Expected path                                                \n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n \u2705  \u2502 EOT20                \u2502 ../../tests/data/tide_models/EOT20/ocean_tides               \n \u2705  \u2502 GOT5.5               \u2502 ../../tests/data/tide_models/GOT5.5/ocean_tides              \n \u2705  \u2502 HAMTIDE11            \u2502 ../../tests/data/tide_models/hamtide                         \n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nSummary:\nAvailable models: 3/50\n</pre> In\u00a0[3]: Copied! <pre># Set the study area (xmin, ymin, xmax, ymax)\nbbox = [122.12, -18.25, 122.43, -17.93]\n\n# Set the time period\nstart_date = \"2022-01-01\"\nend_date = \"2023-12-31\"\n\n# Satellite products and bands to load\nsatellite_sensors = [\"landsat-c2-l2\"]\nbands = [\"green\", \"nir08\"]\n\n# Tide model to use\ntide_model = \"EOT20\"\n</pre> # Set the study area (xmin, ymin, xmax, ymax) bbox = [122.12, -18.25, 122.43, -17.93]  # Set the time period start_date = \"2022-01-01\" end_date = \"2023-12-31\"  # Satellite products and bands to load satellite_sensors = [\"landsat-c2-l2\"] bands = [\"green\", \"nir08\"]  # Tide model to use tide_model = \"EOT20\" In\u00a0[4]: Copied! <pre># Connect to STAC catalog\ncatalog = pystac_client.Client.open(\n    \"https://planetarycomputer.microsoft.com/api/stac/v1\",\n    modifier=planetary_computer.sign_inplace,\n)\n\n# Set cloud access defaults\nodc.stac.configure_rio(\n    cloud_defaults=True,\n    aws={\"aws_unsigned\": True},\n)\n\n# Build a query and search the STAC catalog for all matching items\nquery = catalog.search(\n    bbox=bbox,\n    collections=satellite_sensors,\n    datetime=f\"{start_date}/{end_date}\",\n    query={\n        \"eo:cloud_cover\": {\"lt\": 10},  # Filter to images with &lt;5% cloud\n        \"platform\": {\"in\": [\"landsat-8\", \"landsat-9\"]},  # No Landsat 7\n    },\n)\n\n# Load data into xarray format\nds = odc.stac.load(\n    items=query.item_collection(),\n    bands=bands,\n    crs=\"utm\",\n    resolution=50,\n    groupby=\"solar_day\",\n    bbox=bbox,\n    fail_on_error=False,\n    chunks={},\n)\n\n# Apply USGS Landsat Collection 2 scaling factors to convert\n# surface reflectance to between 0.0 and 1.0. See:\n# https://www.usgs.gov/faqs/how-do-i-use-a-scale-factor-landsat-level-2-science-products\nds = (ds.where(ds != 0) * 0.0000275 + -0.2).clip(0, 1)\nprint(ds)\n</pre> # Connect to STAC catalog catalog = pystac_client.Client.open(     \"https://planetarycomputer.microsoft.com/api/stac/v1\",     modifier=planetary_computer.sign_inplace, )  # Set cloud access defaults odc.stac.configure_rio(     cloud_defaults=True,     aws={\"aws_unsigned\": True}, )  # Build a query and search the STAC catalog for all matching items query = catalog.search(     bbox=bbox,     collections=satellite_sensors,     datetime=f\"{start_date}/{end_date}\",     query={         \"eo:cloud_cover\": {\"lt\": 10},  # Filter to images with &lt;5% cloud         \"platform\": {\"in\": [\"landsat-8\", \"landsat-9\"]},  # No Landsat 7     }, )  # Load data into xarray format ds = odc.stac.load(     items=query.item_collection(),     bands=bands,     crs=\"utm\",     resolution=50,     groupby=\"solar_day\",     bbox=bbox,     fail_on_error=False,     chunks={}, )  # Apply USGS Landsat Collection 2 scaling factors to convert # surface reflectance to between 0.0 and 1.0. See: # https://www.usgs.gov/faqs/how-do-i-use-a-scale-factor-landsat-level-2-science-products ds = (ds.where(ds != 0) * 0.0000275 + -0.2).clip(0, 1) print(ds) <pre>&lt;xarray.Dataset&gt; Size: 454MB\nDimensions:      (time: 121, y: 712, x: 659)\nCoordinates:\n  * y            (y) float64 6kB 8.017e+06 8.017e+06 ... 7.982e+06 7.982e+06\n  * x            (x) float64 5kB 4.068e+05 4.069e+05 ... 4.397e+05 4.397e+05\n    spatial_ref  int32 4B 32751\n  * time         (time) datetime64[ns] 968B 2022-01-01T01:55:34.757654 ... 20...\nData variables:\n    green        (time, y, x) float32 227MB dask.array&lt;chunksize=(1, 712, 659), meta=np.ndarray&gt;\n    nir08        (time, y, x) float32 227MB dask.array&lt;chunksize=(1, 712, 659), meta=np.ndarray&gt;\n</pre> In\u00a0[5]: Copied! <pre># Calculate NDWI\nds[[\"ndwi\"]] = (ds.green - ds.nir08) / (ds.green + ds.nir08) \n\n# Plot a single timestep\nds.ndwi.isel(time=1).odc.explore(vmin=-0.5, vmax=0.5, cmap=\"RdBu\")\n</pre> # Calculate NDWI ds[[\"ndwi\"]] = (ds.green - ds.nir08) / (ds.green + ds.nir08)   # Plot a single timestep ds.ndwi.isel(time=1).odc.explore(vmin=-0.5, vmax=0.5, cmap=\"RdBu\") <pre>/env/lib/python3.10/site-packages/dask/core.py:133: RuntimeWarning: invalid value encountered in divide\n  return func(*(_execute_task(a, cache) for a in args))\n/env/lib/python3.10/site-packages/rasterio/warp.py:387: NotGeoreferencedWarning: Dataset has no geotransform, gcps, or rpcs. The identity matrix will be returned.\n  dest = _reproject(\n</pre> Out[5]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook In\u00a0[6]: Copied! <pre>ds[\"tide_height\"] = tag_tides(\n    data=ds,\n    model=tide_model,\n    directory=directory,\n)\n</pre> ds[\"tide_height\"] = tag_tides(     data=ds,     model=tide_model,     directory=directory, ) <pre>Setting tide modelling location from dataset centroid: 122.27, -18.09\nModelling tides using EOT20\n</pre> <p>We can plot a histogram of the tide heights of our satellite images. This shows that we have decent coverage of the tide range between approximately -2.8 to 3.5 m Above Mean Sea Level (AMSL):</p> In\u00a0[7]: Copied! <pre>ds[\"tide_height\"].plot.hist(bins=10, figsize=(5, 3))\nplt.title(\"Histogram of tide heights in satellite timeseries\");\n</pre> ds[\"tide_height\"].plot.hist(bins=10, figsize=(5, 3)) plt.title(\"Histogram of tide heights in satellite timeseries\"); <p>It is also important to compare our satellite tide observations against the full range of astronomical tides at our location. This lets us become aware of any major biases in our data. For example, here we can see that our data is biased away from low tide observations. This means that our final intertidal maps will underestimate the lower extent of the intertidal zone.</p> In\u00a0[8]: Copied! <pre>tide_stats(\n    data=ds,\n    model=tide_model,\n    directory=directory,\n);\n</pre> tide_stats(     data=ds,     model=tide_model,     directory=directory, ); <pre>Using tide modelling location: 122.27, -18.09\nModelling tides using EOT20\nModelling tides using EOT20\n\n\n\ud83c\udf0a Modelled astronomical tide range: 9.46 metres.\n\ud83d\udef0\ufe0f Observed tide range: 6.37 metres.\n\n\ud83d\udd34 67% of the modelled astronomical tide range was observed at this location.\n\ud83d\udfe1 The highest 12% (1.09 metres) of the tide range was never observed.\n\ud83d\udd34 The lowest 21% (2.00 metres) of the tide range was never observed.\n\n\ud83c\udf0a Mean modelled astronomical tide height: -0.00 metres.\n\ud83d\udef0\ufe0f Mean observed tide height: 0.65 metres.\n\n\u2b06\ufe0f The mean observed tide height was 0.65 metres higher than the mean modelled astronomical tide height.\n</pre> In\u00a0[9]: Copied! <pre># Calculate low and high tide height thresholds\nlowtide_cutoff = 0.2\nhightide_cutoff = 0.8\nlowtide_thresh, hightide_thresh = ds.tide_height.quantile([lowtide_cutoff, hightide_cutoff])\nprint(f\"Low tide threshold: {lowtide_thresh:.2f} metres AMSL\")\nprint(f\"High tide threshold: {hightide_thresh:.2f} metres AMSL\")\n</pre> # Calculate low and high tide height thresholds lowtide_cutoff = 0.2 hightide_cutoff = 0.8 lowtide_thresh, hightide_thresh = ds.tide_height.quantile([lowtide_cutoff, hightide_cutoff]) print(f\"Low tide threshold: {lowtide_thresh:.2f} metres AMSL\") print(f\"High tide threshold: {hightide_thresh:.2f} metres AMSL\") <pre>Low tide threshold: -1.00 metres AMSL\nHigh tide threshold: 2.51 metres AMSL\n</pre> <p>We can now use these thresholds to select just the subset of our data with tide heights lower and higher than our thresholds:</p> In\u00a0[10]: Copied! <pre># Extract subset of low and high tide images\nds_lowtide = ds.sel(time=ds.tide_height &lt;= lowtide_thresh)\nds_hightide = ds.sel(time=ds.tide_height &gt;= hightide_thresh)\n\n# Plot extracted images over all images\nds.tide_height.plot(marker=\"o\", linewidth=0, label=\"Other satellite images\")\nds_hightide.tide_height.plot(marker=\"o\", linewidth=0, label=\"High tide images\")\nds_lowtide.tide_height.plot(marker=\"o\", linewidth=0, label=\"Low tide images\")\nplt.axhline(lowtide_thresh, color=\"black\", linestyle=\"dashed\")\nplt.axhline(hightide_thresh, color=\"black\", linestyle=\"dashed\")\nplt.legend(bbox_to_anchor=(1.01, 0.6))\nplt.title(\"Low and high tide satellite images\");\n</pre> # Extract subset of low and high tide images ds_lowtide = ds.sel(time=ds.tide_height &lt;= lowtide_thresh) ds_hightide = ds.sel(time=ds.tide_height &gt;= hightide_thresh)  # Plot extracted images over all images ds.tide_height.plot(marker=\"o\", linewidth=0, label=\"Other satellite images\") ds_hightide.tide_height.plot(marker=\"o\", linewidth=0, label=\"High tide images\") ds_lowtide.tide_height.plot(marker=\"o\", linewidth=0, label=\"Low tide images\") plt.axhline(lowtide_thresh, color=\"black\", linestyle=\"dashed\") plt.axhline(hightide_thresh, color=\"black\", linestyle=\"dashed\") plt.legend(bbox_to_anchor=(1.01, 0.6)) plt.title(\"Low and high tide satellite images\"); In\u00a0[11]: Copied! <pre># Combine NDWI into single median composites\nndwi_lowtide_median = ds_lowtide.ndwi.median(dim=\"time\")\nndwi_hightide_median = ds_hightide.ndwi.median(dim=\"time\")\n\n# Process our data and load into memory\nndwi_lowtide_median.load()\nndwi_hightide_median.load();\n</pre> # Combine NDWI into single median composites ndwi_lowtide_median = ds_lowtide.ndwi.median(dim=\"time\") ndwi_hightide_median = ds_hightide.ndwi.median(dim=\"time\")  # Process our data and load into memory ndwi_lowtide_median.load() ndwi_hightide_median.load(); <p>Now that we have processed our median NDWI composites, we can plot them on a map:</p> In\u00a0[12]: Copied! <pre>ndwi_lowtide_median.odc.explore(vmin=-0.5, vmax=0.5, cmap=\"RdBu\")\n</pre> ndwi_lowtide_median.odc.explore(vmin=-0.5, vmax=0.5, cmap=\"RdBu\") Out[12]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook In\u00a0[13]: Copied! <pre>ndwi_hightide_median.odc.explore(vmin=-0.5, vmax=0.5, cmap=\"RdBu\")\n</pre> ndwi_hightide_median.odc.explore(vmin=-0.5, vmax=0.5, cmap=\"RdBu\") Out[13]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook <p>Or plot them together for a direct comparison. We can see that the low tide NDWI composite contains additional exposed intertidal terrain along the coastline that becomes inundated at high tide:</p> In\u00a0[14]: Copied! <pre>fig, axes = plt.subplots(1, 2, figsize=(12, 5))\nndwi_lowtide_median.plot.imshow(ax=axes[0], vmin=-0.5, vmax=0.5, cmap=\"RdBu\")\nndwi_hightide_median.plot.imshow(ax=axes[1], vmin=-0.5, vmax=0.5, cmap=\"RdBu\")\naxes[0].set_title(\"Low tide NDWI composite\")\naxes[1].set_title(\"High tide NDWI composite\");\n</pre> fig, axes = plt.subplots(1, 2, figsize=(12, 5)) ndwi_lowtide_median.plot.imshow(ax=axes[0], vmin=-0.5, vmax=0.5, cmap=\"RdBu\") ndwi_hightide_median.plot.imshow(ax=axes[1], vmin=-0.5, vmax=0.5, cmap=\"RdBu\") axes[0].set_title(\"Low tide NDWI composite\") axes[1].set_title(\"High tide NDWI composite\"); In\u00a0[15]: Copied! <pre># Classify our NDWI layers\nndwi_lowtide_bool = ndwi_lowtide_median &gt; 0.0\nndwi_hightide_bool = ndwi_hightide_median &gt; 0.0\n\n# Plot outputs\nfig, axes = plt.subplots(1, 2, figsize=(12, 5))\nndwi_lowtide_bool.plot.imshow(ax=axes[0])\nndwi_hightide_bool.plot.imshow(ax=axes[1])\naxes[0].set_title(\"Low tide classified NDWI\")\naxes[1].set_title(\"High tide classified NDWI\");\n</pre> # Classify our NDWI layers ndwi_lowtide_bool = ndwi_lowtide_median &gt; 0.0 ndwi_hightide_bool = ndwi_hightide_median &gt; 0.0  # Plot outputs fig, axes = plt.subplots(1, 2, figsize=(12, 5)) ndwi_lowtide_bool.plot.imshow(ax=axes[0]) ndwi_hightide_bool.plot.imshow(ax=axes[1]) axes[0].set_title(\"Low tide classified NDWI\") axes[1].set_title(\"High tide classified NDWI\"); <p>Now, we can identify pixels that are <code>True</code> (dry) in our low tide data, and <code>False</code> (wet) in our high tide data. Yellow pixels in our resulting map represent likely intertidal pixels that are exposed at low tide and inundated at high tide!</p> In\u00a0[16]: Copied! <pre>intertidal = ~ndwi_lowtide_bool &amp; ndwi_hightide_bool\nintertidal.odc.explore()\n</pre> intertidal = ~ndwi_lowtide_bool &amp; ndwi_hightide_bool intertidal.odc.explore() Out[16]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook In\u00a0[18]: Copied! <pre>intertidal.astype(\"int16\").odc.write_cog(\"intertidal_map.tif\", overwrite=True);\n</pre> intertidal.astype(\"int16\").odc.write_cog(\"intertidal_map.tif\", overwrite=True);"},{"location":"notebooks/Case_study_intertidal/#mapping-the-intertidal-zone","title":"Mapping the intertidal zone\u00b6","text":"<p>The intertidal zone (i.e. the land along the coast that is periodically inundated by the tide) support important ecological habitats (e.g. sandy beaches and shores, tidal flats and rocky shores and reefs), and provide many valuable benefits such as storm surge protection, carbon storage and natural resources for recreational and commercial use. However, intertidal zones are faced with increasing threats from coastal erosion, land reclamation (e.g. port construction), and sea level rise. Accurate mapping data describing the spatial extents of the intertidal zone are essential for managing these environments, and predicting when and where these threats will have the greatest impact. However, the intertidal zone is challenging and expensive to map at large scale using intensive manual survey methods - particularly across large coastal regions.</p> <p>Satellite Earth observation (EO) data is freely available for the entire planet, making satellite imagery a powerful and cost-effective tool for mapping the intertidal zone at regional, national scale or global scale. This case study will demonstrate a simple intertidal mapping workflow that combines free and open Landsat satellite data with tide modelling from <code>eo-tides</code>. The workflow includes:</p> <ol> <li>Loading a time-series of cloud-free satellite data from the cloud using <code>odc-stac</code></li> <li>Converting our satellite data to a remote sensing water index (NDWI)</li> <li>Modelling tides for each satellite image and inspecting how these observed tides match up to the full local astronomical tide range</li> <li>Filtering our satellite imagery to low and high tide observations</li> <li>Combining noisy individual images into clean low and high tide median NDWI composites</li> <li>Using these composites to extract the extent of the intertidal zone</li> </ol> <p>More information</p> <p>         For more information about the workflows described below, refer to Sagar et al. 2017, Sagar et al. 2018, and Bishop-Taylor et al. 2019.     </p>"},{"location":"notebooks/Case_study_intertidal/#getting-started","title":"Getting started\u00b6","text":"<p>Import any Python packages we need for the analysis:</p>"},{"location":"notebooks/Case_study_intertidal/#tide-model-directory","title":"Tide model directory\u00b6","text":"<p>We need to tell <code>eo-tides</code> the location of our tide model directory (if you haven't set this up, refer to the setup instructions here):</p>"},{"location":"notebooks/Case_study_intertidal/#analysis-parameters","title":"Analysis parameters\u00b6","text":"<p>To make our analysis more re-usable, we can define some important parameters up-front. The default will load Landsat 8 and 9 satellite data from 2022-23 over the city of Broome, Western Australia - a macrotidal region with extensive intertidal coastal habitats.</p> <p>Tip</p> <p>         Leave the defaults below unchanged the first time you run through this notebook.     </p>"},{"location":"notebooks/Case_study_intertidal/#load-satellite-data-using-odc-stac","title":"Load satellite data using odc-stac\u00b6","text":"<p>Now we can load a time-series of satellite data over our area of interest using the Open Data Cube's <code>odc-stac</code> package. This powerful package allows us to load open satellite data (e.g ESA Sentinel-2 or NASA/USGS Landsat) for any time period and location on the planet, and load our data into a multi-dimensional <code>xarray.Dataset</code> format dataset.</p> <p>In this example, we will load our data from the Microsoft Planetary Computer STAC catalogue, and restrict our data to cloud-free images with less than 10% cloud (<code>eo:cloud_cover\": {\"lt\": 10}\"</code>), and load our data at low resolution (<code>resolution=50</code>) to improve load times.</p> <p>Tip</p> <p>         For a more detailed guide to using STAC metadata and <code>odc-stac</code> to find and load satellite data, refer to this STAC user guide.     </p>"},{"location":"notebooks/Case_study_intertidal/#converting-satellite-data-to-ndwi-water-index","title":"Converting satellite data to NDWI water index\u00b6","text":"<p>To help us map the distribution of tidal inundation across our study area, we can convert our spectral bands to a remote sensing water index that enhances contrast between water and dry land. We will use the Normalised Difference Water Index (NDWI), which is particularly useful for intertidal mapping as it is less vulnerable to misclassifications caused by wet sand and mud after high tide:</p> <p>$$ \\text{NDWI} = \\frac{\\text{Green} - \\text{NIR}}{\\text{Green} + \\text{NIR}} $$</p> <p>In the image below, red pixels represent dry land pixels, while blue pixels represent water:</p>"},{"location":"notebooks/Case_study_intertidal/#modelling-tide-heights-for-each-satellite-image","title":"Modelling tide heights for each satellite image\u00b6","text":"<p>We can now use the <code>tag_tides</code> function to model tides for each image in our satellite timeseries:</p>"},{"location":"notebooks/Case_study_intertidal/#exploring-tide-biases","title":"Exploring tide biases\u00b6","text":""},{"location":"notebooks/Case_study_intertidal/#extracting-low-and-high-tide-images","title":"Extracting low and high tide images\u00b6","text":"<p>Now that we have satellite images and associated tide heights, we can filter our data to extract only images from specific tidal stages.</p> <p>In this example, we will focus on extracting low tide and high tide images. We can identify low and high tide images by calculating quantiles of tide heights across time, selecting images from the lowest and highest 20% of tide heights.</p> <p>Tip</p> <p>         Try modifying the <code>lowtide_cutoff</code> and <code>hightide_cutoff</code> tide cutoffs below to customise the tidal stages we will analyse.     </p>"},{"location":"notebooks/Case_study_intertidal/#creating-low-and-high-tide-ndwi-composites","title":"Creating low and high tide NDWI composites\u00b6","text":"<p>Individual satellite images can be affected by many sources of noise, including clouds, saltspray, whitewater and sunglint. These sources of noise can make it difficult to map coastal environments consistently across time and along the coastline.</p> <p>To produce consistent analysis outputs, it can be useful to combine multiple satellite images into a single, cleaner \"composite\" image. This can improve the signal-to-noise ratio of our data, and allow us to map coastal features and change more accurately (at the cost of lower temporal resolution).</p> <p>In this example, we will combine our low and high tide NDWI data into two clean, relatively noise-free low tide and high tide median composites. We use a median calculation for this analysis as medians are extremely robust to noisy data.</p> <p>Important</p> <p>         Note the use of <code>.load()</code> below. Up to this point, our entire analysis has been \"lazy\", which means we haven't loaded the majority of our satellite data - we have simply \"queued\" up our analysis to run in a single step. This makes it quick and easy to write code without having to wait for every step of our workflow to run every time, or ever worrying about running out of memory. Running <code>.load()</code> triggers our entire analysis to run, and then load our final outputs into memory for further use. For more information about lazy loading and processing, see Parallel processing with Dask.     </p> <p>Important</p> <p>         Be patient; this step may take several minutes to complete.     </p>"},{"location":"notebooks/Case_study_intertidal/#mapping-intertidal-extent","title":"Mapping intertidal extent\u00b6","text":"<p>We can now perform a simple comparison of our two outputs to identify intertidal pixels as any pixels that are dry in our low tide composite, but wet in our high tide composite.</p> <p>First, let's classify our NDWI outputs into binary dry (True or 1.0) vs. wet (False or 0.0) using a standard 0.0 NDWI threshold. In the images below, yellow pixels represent water, and purple pixels represent land:</p>"},{"location":"notebooks/Case_study_intertidal/#exporting-data","title":"Exporting data\u00b6","text":"<p>As a final step, we can export our classified intertidal map as a GeoTIFF raster that we can load into a GIS like QGIS or ArcGIS Pro:</p>"},{"location":"notebooks/Case_study_intertidal/#next-steps","title":"Next steps\u00b6","text":"<p>Now that you have completed running this example, here's some possible next steps:</p> <ul> <li>Download the exported <code>intertidal_map.tif</code> and load it into a GIS software (QGIS, ArcGIS Pro) to inspect the output classification.</li> <li>Return to Analysis parameters, and re-run the analysis for a different location (<code>bbox</code>) or time period (<code>start_date</code>, <code>end_date</code>).</li> <li>Try modifying Analysis parameters to select a different tide model (e.g. <code>tide_model=\"GOT5.5\"</code> or <code>tide_model=\"HAMTIDE11\"</code>).</li> <li>Return to Extracting low and high tide images, and change the percentage thresholds (<code>lowtide_cutoff</code>, <code>hightide_cutoff</code>) used to identify low and high tide images.</li> <li>Advanced: In this simple analysis, we filtered to cloud-free images by discarding entire images with more than 10% cloud. Rather than filtering cloud-free images, consider masking clouds at the pixel-level using cloud masking bands that are packaged with the data (e.g. <code>qa_pixel</code>).</li> <li>Advanced: NDWI is just one of many possible remote sensing water indices that can be used for coastal analysis. Update the workflow to use a different water index (e.g. MNDWI), ensuring that you load any new bands required for the index calculation.</li> </ul> <p>In addition, consider the following questions:</p> <ul> <li>What implications do the tide biases calculated in Exploring tide biases have for the outputs of this analysis?</li> <li>Are our outputs likely to fully map the entire intertidal zone? What areas of the intertidal zone are likely to be better or poorly mapped?</li> <li>If you experimented with running the analysis using a different tide model, how does this influence our results?</li> </ul>"},{"location":"notebooks/Model_tides/","title":"Modelling tides","text":"In\u00a0[1]: Copied! <pre>directory = \"../../tests/data/tide_models/\"\n</pre> directory = \"../../tests/data/tide_models/\" <p>Important</p> <p>         The directory above is for demo purposes only.         Update the <code>directory</code> path to point to the location of your own tide model directory.     </p> <p>We can use the <code>eo_tides.utils.list_models</code> function to verify that we have some tide model data available in this directory:</p> In\u00a0[2]: Copied! <pre>from eo_tides.utils import list_models\n\nlist_models(directory=directory, show_supported=False);\n</pre> from eo_tides.utils import list_models  list_models(directory=directory, show_supported=False); <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n \udb40\udc20\ud83c\udf0a  | Model                | Expected path                                                   \n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n \u2705  \u2502 EOT20                \u2502 ../../tests/data/tide_models/EOT20/ocean_tides                  \n \u2705  \u2502 GOT5.5               \u2502 ../../tests/data/tide_models/GOT5.5/ocean_tides                 \n \u2705  \u2502 HAMTIDE11            \u2502 ../../tests/data/tide_models/hamtide                            \n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nSummary:\nAvailable models: 3/51\n</pre> In\u00a0[3]: Copied! <pre>from eo_tides.model import model_tides\nimport pandas as pd\n\ntide_df = model_tides(\n    x=122.2186,\n    y=-18.0008,\n    time=pd.date_range(start=\"2018-01-01\", end=\"2018-01-31\", freq=\"1h\"),\n    directory=directory,\n)\n\n# Print outputs\ntide_df.head()\n</pre> from eo_tides.model import model_tides import pandas as pd  tide_df = model_tides(     x=122.2186,     y=-18.0008,     time=pd.date_range(start=\"2018-01-01\", end=\"2018-01-31\", freq=\"1h\"),     directory=directory, )  # Print outputs tide_df.head() <pre>Modelling tides with EOT20\n</pre> Out[3]: tide_model tide_height time x y 2018-01-01 00:00:00 122.2186 -18.0008 EOT20 1.229286 2018-01-01 01:00:00 122.2186 -18.0008 EOT20 2.162897 2018-01-01 02:00:00 122.2186 -18.0008 EOT20 2.476600 2018-01-01 03:00:00 122.2186 -18.0008 EOT20 2.112390 2018-01-01 04:00:00 122.2186 -18.0008 EOT20 1.181283 <p>The resulting <code>pandas.DataFrame</code> contains:</p> <ul> <li><code>time</code>, <code>x</code>, <code>y</code>: Our original input timesteps and coordinates</li> <li><code>tide_model</code>: a column listing the tide model used</li> <li><code>tide_height</code>: modelled tide heights representing tide height in metres relative to Mean Sea Level</li> </ul> <p>We can plot our modelled outputs to view how tides changed across the month. Looking at the y-axis, we can see that tides at this macrotidal region ranged from -4 metres up to a maximum of +4 metres relative to Mean Sea Level:</p> In\u00a0[4]: Copied! <pre>tide_df.droplevel([\"x\", \"y\"]).tide_height.plot();\n</pre> tide_df.droplevel([\"x\", \"y\"]).tide_height.plot(); In\u00a0[5]: Copied! <pre>tide_df_multiple = model_tides(\n    x=122.2186,\n    y=-18.0008,\n    model=[\"EOT20\", \"HAMTIDE11\", \"GOT5.5\"],\n    time=pd.date_range(start=\"2018-01-01\", end=\"2018-01-31\", freq=\"1h\"),\n    output_format=\"wide\",\n    directory=directory,\n)\n\n# Print outputs\ntide_df_multiple.head()\n</pre> tide_df_multiple = model_tides(     x=122.2186,     y=-18.0008,     model=[\"EOT20\", \"HAMTIDE11\", \"GOT5.5\"],     time=pd.date_range(start=\"2018-01-01\", end=\"2018-01-31\", freq=\"1h\"),     output_format=\"wide\",     directory=directory, )  # Print outputs tide_df_multiple.head() <pre>Modelling tides with EOT20, HAMTIDE11, GOT5.5 in parallel (models: 3, splits: 1)\n</pre> <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3/3 [00:00&lt;00:00, 18.09it/s]\n</pre> <pre>Converting to a wide format dataframe\n</pre> Out[5]: tide_model EOT20 GOT5.5 HAMTIDE11 time x y 2018-01-01 00:00:00 122.2186 -18.0008 1.229286 1.298427 1.422702 2018-01-01 01:00:00 122.2186 -18.0008 2.162897 2.287205 2.302042 2018-01-01 02:00:00 122.2186 -18.0008 2.476600 2.618187 2.537032 2018-01-01 03:00:00 122.2186 -18.0008 2.112390 2.228044 2.072846 2018-01-01 04:00:00 122.2186 -18.0008 1.181283 1.241291 1.034931 <p>Plot our outputs to see all our models on a graph:</p> In\u00a0[6]: Copied! <pre># Print outputs\ntide_df_multiple.droplevel([\"x\", \"y\"]).plot(legend=True)\n</pre> # Print outputs tide_df_multiple.droplevel([\"x\", \"y\"]).plot(legend=True) Out[6]: <pre>&lt;Axes: xlabel='time'&gt;</pre> In\u00a0[7]: Copied! <pre>model_tides(\n    x=[122.21, 122.22],\n    y=[-18.20, -18.21],\n    time=pd.date_range(start=\"2018-01-01\", end=\"2018-01-31\", periods=2),\n    mode=\"one-to-many\",\n    directory=directory,\n)\n</pre> model_tides(     x=[122.21, 122.22],     y=[-18.20, -18.21],     time=pd.date_range(start=\"2018-01-01\", end=\"2018-01-31\", periods=2),     mode=\"one-to-many\",     directory=directory, ) <pre>Modelling tides with EOT20\n</pre> Out[7]: tide_model tide_height time x y 2018-01-01 122.21 -18.20 EOT20 1.231424 2018-01-31 122.21 -18.20 EOT20 0.368303 2018-01-01 122.22 -18.21 EOT20 1.231424 2018-01-31 122.22 -18.21 EOT20 0.368303 <p>However, another common use case is having a list of locations you want to use to model tides for, each with a single timestep. Using \"one-to-one\" mode, we can model tides for each pair of locations and times:</p> <pre><code>2 timesteps at 2 locations = 2 modelled tides\n</code></pre> <p>For example, you may have a <code>pandas.DataFrame</code> containing <code>x</code>, <code>y</code> and <code>time</code> values:</p> In\u00a0[8]: Copied! <pre>df = pd.DataFrame(\n    {\n        \"time\": pd.date_range(start=\"2018-01-01\", end=\"2018-01-31\", periods=2),\n        \"x\": [122.21, 122.22],\n        \"y\": [-18.20, -18.21],\n    }\n)\ndf\n</pre> df = pd.DataFrame(     {         \"time\": pd.date_range(start=\"2018-01-01\", end=\"2018-01-31\", periods=2),         \"x\": [122.21, 122.22],         \"y\": [-18.20, -18.21],     } ) df Out[8]: time x y 0 2018-01-01 122.21 -18.20 1 2018-01-31 122.22 -18.21 <p>We can pass these values to <code>model_tides</code> directly, and run the function in \"one-to-one\" mode to return a tide height for each row:</p> In\u00a0[9]: Copied! <pre># Model tides and add back into dataframe\ndf[\"tide_height\"] = model_tides(\n    x=df.x,\n    y=df.y,\n    time=df.time,\n    mode=\"one-to-one\",\n    directory=directory,\n).tide_height.values\n\n# Print dataframe with added tide height data:\ndf.head()\n</pre> # Model tides and add back into dataframe df[\"tide_height\"] = model_tides(     x=df.x,     y=df.y,     time=df.time,     mode=\"one-to-one\",     directory=directory, ).tide_height.values  # Print dataframe with added tide height data: df.head() <pre>Modelling tides with EOT20\n</pre> Out[9]: time x y tide_height 0 2018-01-01 122.21 -18.20 1.231424 1 2018-01-31 122.22 -18.21 0.368303 In\u00a0[10]: Copied! <pre>model_tides(\n    x=[122.21, 122.22],\n    y=[-18.20, -18.21],\n    time=pd.date_range(start=\"2018-01-01\", end=\"2018-01-31\", periods=2),\n    model=[\"EOT20\", \"GOT5.5\", \"HAMTIDE11\"],\n    output_format=\"long\",\n    directory=directory,\n)\n</pre> model_tides(     x=[122.21, 122.22],     y=[-18.20, -18.21],     time=pd.date_range(start=\"2018-01-01\", end=\"2018-01-31\", periods=2),     model=[\"EOT20\", \"GOT5.5\", \"HAMTIDE11\"],     output_format=\"long\",     directory=directory, ) <pre>Modelling tides with EOT20, GOT5.5, HAMTIDE11 in parallel (models: 3, splits: 1)\n</pre> <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3/3 [00:00&lt;00:00, 18.19it/s]\n</pre> Out[10]: tide_model tide_height time x y 2018-01-01 122.21 -18.20 EOT20 1.231424 2018-01-31 122.21 -18.20 EOT20 0.368303 2018-01-01 122.22 -18.21 EOT20 1.231424 2018-01-31 122.22 -18.21 EOT20 0.368303 2018-01-01 122.21 -18.20 GOT5.5 1.271818 2018-01-31 122.21 -18.20 GOT5.5 0.397214 2018-01-01 122.22 -18.21 GOT5.5 1.271818 2018-01-31 122.22 -18.21 GOT5.5 0.397214 2018-01-01 122.21 -18.20 HAMTIDE11 1.435844 2018-01-31 122.21 -18.20 HAMTIDE11 0.588129 2018-01-01 122.22 -18.21 HAMTIDE11 1.435844 2018-01-31 122.22 -18.21 HAMTIDE11 0.588129 <p>We can also run the function in \"wide\" format, which will return a new column for each tide model (e.g. <code>EOT20</code>, <code>GOT5.5</code>, <code>HAMTIDE11</code> etc):</p> In\u00a0[11]: Copied! <pre>model_tides(\n    x=[122.21, 122.22],\n    y=[-18.20, -18.21],\n    time=pd.date_range(start=\"2018-01-01\", end=\"2018-01-31\", periods=2),\n    model=[\"EOT20\", \"GOT5.5\", \"HAMTIDE11\"],\n    output_format=\"wide\",\n    directory=directory,\n)\n</pre> model_tides(     x=[122.21, 122.22],     y=[-18.20, -18.21],     time=pd.date_range(start=\"2018-01-01\", end=\"2018-01-31\", periods=2),     model=[\"EOT20\", \"GOT5.5\", \"HAMTIDE11\"],     output_format=\"wide\",     directory=directory, ) <pre>Modelling tides with EOT20, GOT5.5, HAMTIDE11 in parallel (models: 3, splits: 1)\n</pre> <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3/3 [00:00&lt;00:00, 18.12it/s]\n</pre> <pre>Converting to a wide format dataframe\n</pre> Out[11]: tide_model EOT20 GOT5.5 HAMTIDE11 time x y 2018-01-01 122.21 -18.20 1.231424 1.271818 1.435844 122.22 -18.21 1.231424 1.271818 1.435844 2018-01-31 122.21 -18.20 0.368303 0.397214 0.588129 122.22 -18.21 0.368303 0.397214 0.588129 In\u00a0[12]: Copied! <pre>from eo_tides.model import model_phases\n\nmodel_phases(\n    x=122.2186,\n    y=-18.0008,\n    time=pd.date_range(start=\"2018-01-01\", end=\"2018-01-02\", freq=\"5h\"),\n    directory=directory,\n)\n</pre> from eo_tides.model import model_phases  model_phases(     x=122.2186,     y=-18.0008,     time=pd.date_range(start=\"2018-01-01\", end=\"2018-01-02\", freq=\"5h\"),     directory=directory, ) <pre>Modelling tides with EOT20\nModelling tides with EOT20\n</pre> Out[12]: tide_model tide_phase time x y 2018-01-01 00:00:00 122.2186 -18.0008 EOT20 high-flow 2018-01-01 05:00:00 122.2186 -18.0008 EOT20 low-ebb 2018-01-01 10:00:00 122.2186 -18.0008 EOT20 low-flow 2018-01-01 15:00:00 122.2186 -18.0008 EOT20 high-ebb 2018-01-01 20:00:00 122.2186 -18.0008 EOT20 low-ebb <p>The resulting <code>pandas.DataFrame</code> contains:</p> <ul> <li><code>time</code>, <code>x</code>, <code>y</code>: Our original input timesteps and coordinates</li> <li><code>tide_model</code>: a column listing the tide model used</li> <li><code>tide_phase</code>: the modelled tidal phase (\"high-flow\", \"high-ebb\", \"low-ebb\", \"low-flow\").</li> </ul> <p><code>model_phases</code> accepts all parameters accepted by <code>model_tides</code>; e.g. <code>model</code> and <code>output_format</code>:</p> In\u00a0[13]: Copied! <pre>model_phases(\n    x=122.2186,\n    y=-18.0008,\n    time=pd.date_range(start=\"2018-01-01\", end=\"2018-01-02\", freq=\"5h\"),\n    model=[\"EOT20\", \"GOT5.5\"],\n    output_format=\"wide\",\n    directory=directory,\n)\n</pre> model_phases(     x=122.2186,     y=-18.0008,     time=pd.date_range(start=\"2018-01-01\", end=\"2018-01-02\", freq=\"5h\"),     model=[\"EOT20\", \"GOT5.5\"],     output_format=\"wide\",     directory=directory, ) <pre>Modelling tides with EOT20, GOT5.5 in parallel (models: 2, splits: 1)\n</pre> <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 2/2 [00:00&lt;00:00, 12.91it/s]\n</pre> <pre>Modelling tides with EOT20, GOT5.5 in parallel (models: 2, splits: 1)\n</pre> <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 2/2 [00:00&lt;00:00, 13.08it/s]\n</pre> <pre>Converting to a wide format dataframe\n</pre> Out[13]: tide_model EOT20 GOT5.5 time x y 2018-01-01 00:00:00 122.2186 -18.0008 high-flow high-flow 2018-01-01 05:00:00 122.2186 -18.0008 low-ebb low-ebb 2018-01-01 10:00:00 122.2186 -18.0008 low-flow low-flow 2018-01-01 15:00:00 122.2186 -18.0008 high-ebb high-ebb 2018-01-01 20:00:00 122.2186 -18.0008 low-ebb low-ebb <p>To change the default 15 minute time offset used to calculate tide phases, pass a custom value to <code>time_offset</code>:</p> In\u00a0[14]: Copied! <pre>model_phases(\n    x=122.2186,\n    y=-18.0008,\n    time=pd.date_range(start=\"2018-01-01\", end=\"2018-01-02\", freq=\"5h\"),\n    time_offset='30 min',\n    directory=directory,\n)\n</pre> model_phases(     x=122.2186,     y=-18.0008,     time=pd.date_range(start=\"2018-01-01\", end=\"2018-01-02\", freq=\"5h\"),     time_offset='30 min',     directory=directory, ) <pre>Modelling tides with EOT20\nModelling tides with EOT20\n</pre> Out[14]: tide_model tide_phase time x y 2018-01-01 00:00:00 122.2186 -18.0008 EOT20 high-flow 2018-01-01 05:00:00 122.2186 -18.0008 EOT20 low-ebb 2018-01-01 10:00:00 122.2186 -18.0008 EOT20 low-flow 2018-01-01 15:00:00 122.2186 -18.0008 EOT20 high-ebb 2018-01-01 20:00:00 122.2186 -18.0008 EOT20 low-ebb <p>Optionally, we can choose to return also tide heights by providing <code>return_tides=True</code>. This will include an additional <code>tide_height</code> column in our dataframe:</p> In\u00a0[15]: Copied! <pre>phase_df = model_phases(\n    x=122.2186,\n    y=-18.0008,\n    time=pd.date_range(start=\"2018-01-01\", end=\"2018-01-02\", freq=\"30min\"),\n    return_tides=True,\n    directory=directory,\n)\n\n# Print outputs\nphase_df.head()\n</pre> phase_df = model_phases(     x=122.2186,     y=-18.0008,     time=pd.date_range(start=\"2018-01-01\", end=\"2018-01-02\", freq=\"30min\"),     return_tides=True,     directory=directory, )  # Print outputs phase_df.head() <pre>Modelling tides with EOT20\nModelling tides with EOT20\n</pre> Out[15]: tide_model tide_height tide_phase time x y 2018-01-01 00:00:00 122.2186 -18.0008 EOT20 1.229286 high-flow 2018-01-01 00:30:00 122.2186 -18.0008 EOT20 1.763103 high-flow 2018-01-01 01:00:00 122.2186 -18.0008 EOT20 2.162897 high-flow 2018-01-01 01:30:00 122.2186 -18.0008 EOT20 2.405015 high-flow 2018-01-01 02:00:00 122.2186 -18.0008 EOT20 2.476600 high-flow <p>If we plot our <code>tide_height</code> and <code>tide_phase</code> data, we can see it follows a logical progression from <code>high-flow -&gt; high-ebb -&gt; low-ebb -&gt; low-flow -&gt; ...</code>, repeating with every tide cycle:</p> In\u00a0[16]: Copied! <pre># Plot tide heights\nax = phase_df.droplevel([\"x\", \"y\"]).tide_height.plot(color=\"black\")\n\n# Define plotting parameters for each phase\nplot_params = {\n    \"high-flow\": {\"marker\": \"^\", \"color\": \"tab:blue\"},\n    \"high-ebb\": {\"marker\": \"v\", \"color\": \"tab:blue\"},\n    \"low-flow\": {\"marker\": \"^\", \"color\": \"tab:orange\"},\n    \"low-ebb\": {\"marker\": \"v\", \"color\": \"tab:orange\"},\n}\n\n# Plot each phase\nfor phase, params in plot_params.items():\n    phase_df.droplevel([\"x\", \"y\"]).query(f\"tide_phase == '{phase}'\").tide_height.plot(\n        marker=params[\"marker\"],\n        linewidth=0.0,\n        color=params[\"color\"],\n        markersize=10,\n        label=phase,\n    )\nax.legend();\n</pre> # Plot tide heights ax = phase_df.droplevel([\"x\", \"y\"]).tide_height.plot(color=\"black\")  # Define plotting parameters for each phase plot_params = {     \"high-flow\": {\"marker\": \"^\", \"color\": \"tab:blue\"},     \"high-ebb\": {\"marker\": \"v\", \"color\": \"tab:blue\"},     \"low-flow\": {\"marker\": \"^\", \"color\": \"tab:orange\"},     \"low-ebb\": {\"marker\": \"v\", \"color\": \"tab:orange\"}, }  # Plot each phase for phase, params in plot_params.items():     phase_df.droplevel([\"x\", \"y\"]).query(f\"tide_phase == '{phase}'\").tide_height.plot(         marker=params[\"marker\"],         linewidth=0.0,         color=params[\"color\"],         markersize=10,         label=phase,     ) ax.legend();"},{"location":"notebooks/Model_tides/#modelling-tides","title":"Modelling tides\u00b6","text":"<p>This guide demonstrates how to use the <code>model_tides</code> and <code>model_phases</code> functions from the <code>eo_tides.model</code> module to model tide heights and phases at multiple coordinates or time steps, using one or more ocean tide models.</p> <p>The <code>model_tides</code> function supports tide modelling based on a wide range of ocean tide models using a single line of code, parallelising this modelling where possible and returning data in a standardised <code>pandas.Dataframe</code> format. The <code>model_tides</code> function can be used independently of Earth observation (EO) data, e.g. for any application where you need to generate a time series of tide heights. However, it also underpins the more complex EO-related functions demonstrated in Combining tides with satellite data.</p> <p>The <code>model_phases</code> function can be used to model the phase of the tide at any location and time. This can be used to classify tides into high and low tide observations, or determine whether the tide was rising (i.e. flow tide) or falling (i.e. ebb tide).</p> <p>Tip</p> <p>         The <code>model_tides</code> function is based on the <code>pyTMD.compute.tide_elevations</code> function from the <code>pyTMD</code> tide modelling package that underpins <code>eo-tides</code>, with modifications to support parallel processing and integration with <code>pandas</code> and <code>xarray</code> workflows. We highly recommend exploring the more advanced tide modelling functionality available in <code>pyTMD</code> for more custom tide modelling applications.     </p>"},{"location":"notebooks/Model_tides/#getting-started","title":"Getting started\u00b6","text":"<p>As a first step, we need to tell <code>eo-tides</code> the location of our tide model or clipped tide model directory (if you haven't set this up, refer to the setup instructions here).</p> <p>We will pass this path to <code>eo-tides</code> functions using the <code>directory</code> parameter.</p>"},{"location":"notebooks/Model_tides/#using-model_tides","title":"Using model_tides\u00b6","text":"<p>In the example below, we use the <code>model_tides</code> function to model hourly tides for the city of Broome, Western Australia across January 2018:</p>"},{"location":"notebooks/Model_tides/#multiple-models","title":"Multiple models\u00b6","text":"<p>By default, <code>model_tides</code> will model tides using the <code>EOT20</code> tide model \u2013 a leading open-source global ocean model with a permissive CC BY 4.0 licence:</p> <p>Hart-Davis Michael, Piccioni Gaia, Dettmering Denise, Schwatke Christian, Passaro Marcello, Seitz Florian (2021). EOT20 - A global Empirical Ocean Tide model from multi-mission satellite altimetry. SEANOE. https://doi.org/10.17882/79489</p> <p>However, we can easily model tides using multiple models by passing a list of models to the <code>model</code> parameter. <code>eo-tides</code> will process these in parallel where possible, and return the data into a single <code>pandas.DataFrame</code>. For example, we can model tides using the <code>EOT20</code>, <code>GOT5.5</code> and <code>HAMTIDE11</code> models:</p> <p>Note</p> <p>         Here we also set <code>output_format=\"wide\"</code>, which will place data from each model into a new column.         This can make it easier to plot our data. For more details, see below.     </p>"},{"location":"notebooks/Model_tides/#one-to-many-and-one-to-one-modes","title":"\"One-to-many\" and \"one-to-one\" modes\u00b6","text":"<p>By default, the <code>model_tides</code> function operates in \"one-to-many\" mode, which will model tides at every requested location, for every requested timestep. This is particularly useful for satellite Earth observation applications where we may want to model tides for a large set of satellite pixels, for every satellite acquisition through time.</p> <p>For example, if we provide two locations and two timesteps, the function will return four modelled tides:</p> <pre><code>2 locations * 2 timesteps = 4 modelled tides\n</code></pre>"},{"location":"notebooks/Model_tides/#wide-and-long-output-formats","title":"\"Wide\" and \"long\" output formats\u00b6","text":"<p>By default, modelled tides will be returned in \"long\" format, with multiple models stacked under a <code>tide_models</code> column and tide heights in the <code>tide_height</code> column:</p>"},{"location":"notebooks/Model_tides/#using-model_phases","title":"Using model_phases\u00b6","text":"<p>In addition to tide height, it can be useful to obtain information about the phase of the tide at each observation. For example, we may want to know whether tides were low or high, or whether water levels were rising (\"flow\" tide) or falling (\"ebb\" tide). Tide phase data can provide valuable contextual information for interpreting satellite imagery, particularly in tidal flat or mangrove forest environments where water may remain in the landscape for considerable time after the tidal peak.</p> <p>The <code>model_phases</code> function calculates ebb and low phases by modelling tides once for the requested timesteps, and again after subtracting a small time offset (by default, 15 minutes). If tides increased over this period, they are assigned as \"flow\"; if they decreased, they are assigned as \"ebb\". Tides are considered \"high\" if equal or greater than 0 metres tide height, otherwise \"low\".</p> <p>We can run <code>model_phases</code> by providing <code>x</code> and <code>y</code> coordinates and <code>time</code>:</p>"},{"location":"notebooks/Model_tides/#next-steps","title":"Next steps\u00b6","text":"<p>Now that we have demonstrated how to model tide heights and phases, we can learn how to combine modelled tides with satellite data for further analysis.</p>"},{"location":"notebooks/Satellite_data/","title":"Combining tides with satellite data","text":"In\u00a0[1]: Copied! <pre>directory = \"../../tests/data/tide_models/\"\n</pre> directory = \"../../tests/data/tide_models/\" In\u00a0[2]: Copied! <pre>import odc.stac\nimport pystac_client\n\n# Connect to STAC catalog\ncatalog = pystac_client.Client.open(\"https://explorer.dea.ga.gov.au/stac\")\n\n# Set cloud access defaults\nodc.stac.configure_rio(\n    cloud_defaults=True,\n    aws={\"aws_unsigned\": True},\n)\n\n# Build a query and search the STAC catalog for all matching items\nbbox = [122.12, -18.25, 122.43, -17.93]\nquery = catalog.search(\n    bbox=bbox,\n    collections=[\"ga_ls8c_ard_3\", \"ga_ls9c_ard_3\"],\n    datetime=\"2024-01-01/2024-12-31\",\n    filter = \"eo:cloud_cover &lt; 5\"  # Filter to images with &lt;5% cloud\n)\n\n# Load data into xarray format\nds = odc.stac.load(\n    items=list(query.items()),\n    bands=[\"nbart_red\", \"nbart_green\", \"nbart_blue\"],\n    crs=\"utm\",\n    resolution=30,\n    groupby=\"solar_day\",\n    bbox=bbox,\n    fail_on_error=False,\n    chunks={},\n)\n\n# Plot the first image\nds.isel(time=0).odc.explore(vmin=50, vmax=3000)\n</pre> import odc.stac import pystac_client  # Connect to STAC catalog catalog = pystac_client.Client.open(\"https://explorer.dea.ga.gov.au/stac\")  # Set cloud access defaults odc.stac.configure_rio(     cloud_defaults=True,     aws={\"aws_unsigned\": True}, )  # Build a query and search the STAC catalog for all matching items bbox = [122.12, -18.25, 122.43, -17.93] query = catalog.search(     bbox=bbox,     collections=[\"ga_ls8c_ard_3\", \"ga_ls9c_ard_3\"],     datetime=\"2024-01-01/2024-12-31\",     filter = \"eo:cloud_cover &lt; 5\"  # Filter to images with &lt;5% cloud )  # Load data into xarray format ds = odc.stac.load(     items=list(query.items()),     bands=[\"nbart_red\", \"nbart_green\", \"nbart_blue\"],     crs=\"utm\",     resolution=30,     groupby=\"solar_day\",     bbox=bbox,     fail_on_error=False,     chunks={}, )  # Plot the first image ds.isel(time=0).odc.explore(vmin=50, vmax=3000) <pre>/env/lib/python3.10/site-packages/odc/geo/_rgba.py:56: RuntimeWarning: invalid value encountered in cast\n  return x.astype(\"uint8\")\n/env/lib/python3.10/site-packages/rasterio/warp.py:387: NotGeoreferencedWarning: Dataset has no geotransform, gcps, or rpcs. The identity matrix will be returned.\n  dest = _reproject(\n</pre> Out[2]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook In\u00a0[3]: Copied! <pre>from eo_tides.eo import tag_tides\n\ntides_da = tag_tides(\n    data=ds,\n    directory=directory,\n)\n\n# Print modelled tides\nprint(tides_da)\n</pre> from eo_tides.eo import tag_tides  tides_da = tag_tides(     data=ds,     directory=directory, )  # Print modelled tides print(tides_da) <pre>Setting tide modelling location from dataset centroid: 122.27, -18.09\nModelling tides with EOT20\n&lt;xarray.DataArray 'tide_height' (time: 45)&gt; Size: 180B\narray([-0.25108945,  0.5275667 ,  1.5171705 ,  2.011433  ,  0.36809078,\n        1.9124153 ,  1.0965405 ,  1.1305977 , -0.21305004,  1.7526643 ,\n       -0.2175682 , -0.80696225, -0.9524483 ,  3.0443938 , -1.3169092 ,\n        3.3964403 ,  2.625125  , -0.9654651 , -0.4368508 ,  2.581808  ,\n        1.7244624 , -1.0423656 ,  0.16597499,  0.73508024, -0.33408186,\n       -0.10130765,  0.7978594 , -1.8499157 ,  1.6090035 , -1.2717861 ,\n       -1.8342571 ,  2.162794  ,  2.7683735 , -2.6152036 , -2.39916   ,\n        2.5937896 ,  2.1230242 , -1.6377252 ,  3.2850509 , -0.3772273 ,\n        0.6212255 ,  1.6580964 ,  0.71566176, -0.03352478,  1.0641807 ],\n      dtype=float32)\nCoordinates:\n  * time        (time) datetime64[ns] 360B 2024-01-07T01:55:31.679580 ... 202...\n    tide_model  &lt;U5 20B 'EOT20'\n</pre> <p>We can easily combine these modelled tides with our original satellite data for further analysis. The code below adds our modelled tides as a new <code>tide_height</code> variable under Data variables.</p> In\u00a0[4]: Copied! <pre>ds[\"tide_height\"] = tides_da\nprint(ds)\n</pre> ds[\"tide_height\"] = tides_da print(ds) <pre>&lt;xarray.Dataset&gt; Size: 703MB\nDimensions:      (y: 1185, x: 1099, time: 45)\nCoordinates:\n  * y            (y) float64 9kB 8.017e+06 8.017e+06 ... 7.982e+06 7.982e+06\n  * x            (x) float64 9kB 4.068e+05 4.068e+05 ... 4.397e+05 4.398e+05\n    spatial_ref  int32 4B 32751\n  * time         (time) datetime64[ns] 360B 2024-01-07T01:55:31.679580 ... 20...\n    tide_model   &lt;U5 20B 'EOT20'\nData variables:\n    nbart_red    (time, y, x) float32 234MB dask.array&lt;chunksize=(1, 1185, 1099), meta=np.ndarray&gt;\n    nbart_green  (time, y, x) float32 234MB dask.array&lt;chunksize=(1, 1185, 1099), meta=np.ndarray&gt;\n    nbart_blue   (time, y, x) float32 234MB dask.array&lt;chunksize=(1, 1185, 1099), meta=np.ndarray&gt;\n    tide_height  (time) float32 180B -0.2511 0.5276 1.517 ... -0.03352 1.064\n</pre> <p>Tip</p> <p>         You could also model tides and insert tide heights into <code>ds</code> in a single step via: <code>ds[\"tide_height\"] = tag_tides(ds, ...)</code> </p> <p>We can plot this new <code>tide_height</code> variable over time to inspect the tide heights observed by the satellites in our time series:</p> In\u00a0[5]: Copied! <pre>ds.tide_height.plot()\n</pre> ds.tide_height.plot() Out[5]: <pre>[&lt;matplotlib.lines.Line2D at 0x7f6056bfc850&gt;]</pre> In\u00a0[6]: Copied! <pre># Sort by tide and plot the first and last image\nds_sorted = ds.sortby(\"tide_height\")\nds_sorted.isel(time=[0, -1]).odc.to_rgba(vmin=50, vmax=3000).plot.imshow(col=\"time\")\n</pre> # Sort by tide and plot the first and last image ds_sorted = ds.sortby(\"tide_height\") ds_sorted.isel(time=[0, -1]).odc.to_rgba(vmin=50, vmax=3000).plot.imshow(col=\"time\") Out[6]: <pre>&lt;xarray.plot.facetgrid.FacetGrid at 0x7f6056ae61a0&gt;</pre> In\u00a0[7]: Copied! <pre># Load data into xarray format\nds = odc.stac.load(\n    items=list(query.items()),\n    bands=[\"nbart_red\", \"nbart_green\", \"nbart_blue\"],\n    crs=\"utm\",\n    resolution=30,\n    groupby=\"solar_day\",\n    bbox=bbox,\n    fail_on_error=False,\n    chunks={},\n)\n</pre> # Load data into xarray format ds = odc.stac.load(     items=list(query.items()),     bands=[\"nbart_red\", \"nbart_green\", \"nbart_blue\"],     crs=\"utm\",     resolution=30,     groupby=\"solar_day\",     bbox=bbox,     fail_on_error=False,     chunks={}, ) <p>Now run <code>pixel_tides</code>, passing our satellite dataset <code>ds</code> as an input:</p> In\u00a0[8]: Copied! <pre>from eo_tides.eo import pixel_tides\n\n# Model tides spatially\ntides_lowres = pixel_tides(\n    data=ds,\n    resample=False,\n    directory=directory,\n)\n\n# Print output\nprint(tides_lowres)\n</pre> from eo_tides.eo import pixel_tides  # Model tides spatially tides_lowres = pixel_tides(     data=ds,     resample=False,     directory=directory, )  # Print output print(tides_lowres) <pre>Creating reduced resolution 5000 x 5000 metre tide modelling array\nModelling tides with EOT20\nReturning low resolution tide array\n&lt;xarray.DataArray 'tide_height' (time: 45, y: 13, x: 13)&gt; Size: 30kB\narray([[[-0.30606133, -0.30717686, -0.30773783, ..., -0.25615942,\n         -0.25615942, -0.25615942],\n        [-0.30401564, -0.30424863, -0.30387282, ..., -0.25615942,\n         -0.25615942, -0.25615942],\n        [-0.30068266, -0.29933682, -0.29704148, ..., -0.25615942,\n         -0.25615942, -0.25615942],\n        ...,\n        [-0.27365166, -0.27505815, -0.2606054 , ..., -0.25108945,\n         -0.25108945, -0.25108945],\n        [-0.27030516, -0.26545134, -0.26545134, ..., -0.25108945,\n         -0.25108945, -0.25108945],\n        [-0.26545134, -0.26545134, -0.26545134, ..., -0.25108945,\n         -0.25108945, -0.25108945]],\n\n       [[ 0.4048146 ,  0.40729165,  0.4100286 , ...,  0.51402086,\n          0.51402086,  0.51402086],\n        [ 0.41507572,  0.41939604,  0.42421374, ...,  0.51402086,\n          0.51402086,  0.51402086],\n        [ 0.42650127,  0.43261963,  0.43943623, ...,  0.51402086,\n          0.51402086,  0.51402086],\n...\n        [-0.05945582, -0.06040129, -0.04247594, ..., -0.03352478,\n         -0.03352478, -0.03352478],\n        [-0.05551685, -0.04903932, -0.04903932, ..., -0.03352478,\n         -0.03352478, -0.03352478],\n        [-0.04903932, -0.04903932, -0.04903932, ..., -0.03352478,\n         -0.03352478, -0.03352478]],\n\n       [[ 0.88739955,  0.90003395,  0.91273254, ...,  1.0558591 ,\n          1.0558591 ,  1.0558591 ],\n        [ 0.9003904 ,  0.91464955,  0.9293343 , ...,  1.0558591 ,\n          1.0558591 ,  1.0558591 ],\n        [ 0.9152668 ,  0.93159544,  0.9488063 , ...,  1.0558591 ,\n          1.0558591 ,  1.0558591 ],\n        ...,\n        [ 1.0099615 ,  1.0095476 ,  1.0438287 , ...,  1.0641807 ,\n          1.0641807 ,  1.0641807 ],\n        [ 1.0166272 ,  1.026946  ,  1.026946  , ...,  1.0641807 ,\n          1.0641807 ,  1.0641807 ],\n        [ 1.026946  ,  1.026946  ,  1.026946  , ...,  1.0641807 ,\n          1.0641807 ,  1.0641807 ]]], dtype=float32)\nCoordinates:\n  * time         (time) datetime64[ns] 360B 2024-01-07T01:55:31.679580 ... 20...\n  * x            (x) float64 104B 3.925e+05 3.975e+05 ... 4.475e+05 4.525e+05\n  * y            (y) float64 104B 8.028e+06 8.022e+06 ... 7.972e+06 7.968e+06\n    tide_model   &lt;U5 20B 'EOT20'\n    spatial_ref  int32 4B 32751\n</pre> <p>If we plot the resulting data, we can see that we now have two-dimensional tide surfaces for each timestep in our data (instead of the single tide height per timestamp returned by the <code>tag_tides</code> function).</p> <p>Blue values below indicate low tide pixels, while red indicates high tide pixels. If you look closely, you may see some spatial variability in tide heights within each timestep, with slight variations in tide heights along the north-west side of the study area:</p> In\u00a0[9]: Copied! <pre># Plot the first four timesteps in our data\ntides_lowres.isel(time=slice(0, 4)).plot.imshow(col=\"time\", vmin=-1, vmax=1, cmap=\"RdBu\")\n</pre> # Plot the first four timesteps in our data tides_lowres.isel(time=slice(0, 4)).plot.imshow(col=\"time\", vmin=-1, vmax=1, cmap=\"RdBu\") Out[9]: <pre>&lt;xarray.plot.facetgrid.FacetGrid at 0x7f60811c18a0&gt;</pre> In\u00a0[10]: Copied! <pre># Model tides spatially\ntides_highres = pixel_tides(\n    data=ds,\n    resample=True,\n    directory=directory,\n)\n\n# Plot the first four timesteps in our data\ntides_highres.isel(time=slice(0, 4)).plot.imshow(col=\"time\", vmin=-1, vmax=1, cmap=\"RdBu\")\n</pre> # Model tides spatially tides_highres = pixel_tides(     data=ds,     resample=True,     directory=directory, )  # Plot the first four timesteps in our data tides_highres.isel(time=slice(0, 4)).plot.imshow(col=\"time\", vmin=-1, vmax=1, cmap=\"RdBu\") <pre>Creating reduced resolution 5000 x 5000 metre tide modelling array\nModelling tides with EOT20\nReprojecting tides into original resolution\n</pre> Out[10]: <pre>&lt;xarray.plot.facetgrid.FacetGrid at 0x7f6047d99fc0&gt;</pre> <p><code>tides_highres</code> will have exactly the same dimensions as <code>ds</code>, with a unique tide height for every satellite pixel:</p> In\u00a0[11]: Copied! <pre>ds.sizes\n</pre> ds.sizes Out[11]: <pre>Frozen({'y': 1185, 'x': 1099, 'time': 45})</pre> In\u00a0[12]: Copied! <pre>tides_highres.sizes\n</pre> tides_highres.sizes Out[12]: <pre>Frozen({'time': 45, 'y': 1185, 'x': 1099})</pre> <p>Because of this, our stack of tides can be added as an additional 3D variable in our dataset:</p> In\u00a0[13]: Copied! <pre>ds[\"tide_height_pixel\"] = tides_highres\nprint(ds)\n</pre> ds[\"tide_height_pixel\"] = tides_highres print(ds) <pre>&lt;xarray.Dataset&gt; Size: 938MB\nDimensions:            (y: 1185, x: 1099, time: 45)\nCoordinates:\n  * y                  (y) float64 9kB 8.017e+06 8.017e+06 ... 7.982e+06\n  * x                  (x) float64 9kB 4.068e+05 4.068e+05 ... 4.398e+05\n    spatial_ref        int32 4B 32751\n  * time               (time) datetime64[ns] 360B 2024-01-07T01:55:31.679580 ...\n    tide_model         &lt;U5 20B 'EOT20'\nData variables:\n    nbart_red          (time, y, x) float32 234MB dask.array&lt;chunksize=(1, 1185, 1099), meta=np.ndarray&gt;\n    nbart_green        (time, y, x) float32 234MB dask.array&lt;chunksize=(1, 1185, 1099), meta=np.ndarray&gt;\n    nbart_blue         (time, y, x) float32 234MB dask.array&lt;chunksize=(1, 1185, 1099), meta=np.ndarray&gt;\n    tide_height_pixel  (time, y, x) float32 234MB -0.3038 -0.3039 ... 1.064\n</pre> In\u00a0[14]: Copied! <pre># Model tides spatially\ntides_highres_quantiles = pixel_tides(\n    data=ds,\n    calculate_quantiles=(0, 0.5, 1),\n    directory=directory,\n)\n\n# Plot quantiles\ntides_highres_quantiles.plot.imshow(col=\"quantile\")\n</pre> # Model tides spatially tides_highres_quantiles = pixel_tides(     data=ds,     calculate_quantiles=(0, 0.5, 1),     directory=directory, )  # Plot quantiles tides_highres_quantiles.plot.imshow(col=\"quantile\") <pre>Creating reduced resolution 5000 x 5000 metre tide modelling array\nModelling tides with EOT20\nComputing tide quantiles\nReprojecting tides into original resolution\n</pre> Out[14]: <pre>&lt;xarray.plot.facetgrid.FacetGrid at 0x7f6047cf2350&gt;</pre> In\u00a0[15]: Copied! <pre>import pandas as pd\n\ncustom_times = pd.date_range(\n    start=\"2022-01-01\", \n    end=\"2022-01-02\", \n    freq=\"6H\",\n)\n\n# Model tides spatially\ntides_highres = pixel_tides(\n    data=ds, \n    time=custom_times,\n    directory=directory,\n)\n\n# Plot custom timesteps\ntides_highres.plot.imshow(col=\"time\")\n</pre> import pandas as pd  custom_times = pd.date_range(     start=\"2022-01-01\",      end=\"2022-01-02\",      freq=\"6H\", )  # Model tides spatially tides_highres = pixel_tides(     data=ds,      time=custom_times,     directory=directory, )  # Plot custom timesteps tides_highres.plot.imshow(col=\"time\") <pre>Creating reduced resolution 5000 x 5000 metre tide modelling array\nModelling tides with EOT20\nReprojecting tides into original resolution\n</pre> Out[15]: <pre>&lt;xarray.plot.facetgrid.FacetGrid at 0x7f6047be1000&gt;</pre>"},{"location":"notebooks/Satellite_data/#combining-tides-with-satellite-data","title":"Combining tides with satellite data\u00b6","text":"<p>This guide demonstrates how to combine tide modelling with satellite Earth observation (EO) data using the <code>tag_tides</code> and <code>pixel_tides</code> functions from <code>eo_tides.eo</code>.</p> <p>Both these functions allow you to model the height of the tide at the exact moment of satellite image acquisition. This can then allow you to analyse satellite EO data by tidal conditions - for example, filter your data to satellite imagery collected during specific tidal stages (e.g. low or high tide).</p> <p>Although both functions perform a similar function, they differ in complexity and performance. <code>tag_tides</code> assigns a single tide height to each timestep/satellite image, which is fast and efficient, and suitable for small-scale applications where tides are unlikely to vary across your study area. In constrast, <code>pixel_tide</code> models tides both through time and spatially, returning a tide height for every satellite pixel. This can be critical for producing seamless coastal EO datasets at large scale - however comes at the cost of performance. </p> <p>Table 1. Comparison of <code>tag_tides</code> and <code>pixel_tides</code></p> <code>tag_tides</code> <code>pixel_tides</code> Assigns a single tide height to each timestep/satellite image Assigns a tide height to every individual pixel through time to capture spatial tide dynamics \ud83d\udd0e Ideal for local or site-scale analysis \ud83c\udf0f Ideal for regional to global-scale coastal product generation \u2705 Fast, low memory use \u274c Slower, higher memory use \u274c Single tide height per image can produce artefacts in complex tidal regions \u2705 Produce spatially seamless results across large extents by applying analyses at the pixel level"},{"location":"notebooks/Satellite_data/#getting-started","title":"Getting started\u00b6","text":"<p>As in the previous example, our first step is to tell <code>eo-tides</code> the location of our tide model or clipped tide model directory (if you haven't set this up, refer to the setup instructions here):</p>"},{"location":"notebooks/Satellite_data/#load-satellite-data-using-odc-stac","title":"Load satellite data using odc-stac\u00b6","text":"<p>Now we can load a time-series of satellite data over our area of interest using the Open Data Cube's <code>odc-stac</code> package. This powerful package allows us to load open satellite data (e.g ESA Sentinel-2 or NASA/USGS Landsat) for any time period and location on the planet, and load our data into a multi-dimensional <code>xarray.Dataset</code> format dataset.</p> <p>In this example, we will load Landsat 8 and 9 satellite data from 2024 over the city of Broome, Western Australia - a macrotidal region with extensive intertidal coastal habitats. We will load this data from the Digital Earth Australia STAC catalogue.</p> <p>Tip</p> <p>         For a more detailed guide to using STAC metadata and <code>odc-stac</code> to find and load satellite data, refer to the Digital Earth Australia STAC user guide.     </p>"},{"location":"notebooks/Satellite_data/#using-tag_tides","title":"Using tag_tides\u00b6","text":"<p>We can pass our satellite dataset <code>ds</code> to the <code>tag_tides</code> function to model a tide for each timestep in our dataset. This can help sort and filter images by tide height, allowing us to learn more about how coastal environments respond to the effect of changing tides.</p> <p>The <code>tag_tides</code> function uses the time and date of acquisition and the geographic centroid of each satellite observation as inputs for the selected tide model (EOT20 by default). It returns an <code>xarray.DataArray</code> called <code>tide_height</code>, with a modelled tide for every timestep in our satellite dataset:</p>"},{"location":"notebooks/Satellite_data/#selecting-and-analysing-satellite-data-by-tide","title":"Selecting and analysing satellite data by tide\u00b6","text":"<p>Having <code>tide_height</code> as a variable allows us to select and analyse our satellite data using information about tides. For example, we could sort by <code>tide_height</code>, then plot the lowest and highest tide images in our time series:</p>"},{"location":"notebooks/Satellite_data/#using-pixel_tides","title":"Using pixel_tides\u00b6","text":"<p>The previous examples show how to model a single tide height for each satellite image using the centroid of the image as a tide modelling location. However, in reality tides vary spatially \u2013 potentially by several metres in areas of complex tidal dynamics. This means that an individual satellite image can capture a range of tide conditions.</p> <p>We can use the <code>pixel_tides</code> function to capture this spatial variability in tide heights. For efficient processing, this function first models tides into a low resolution grid surrounding each satellite image in our time series. This lower resolution data includes a buffer around the extent of our satellite data so that tides can be modelled seamlessly across analysis boundaries.</p> <p>First, let's reload our satellite data for a fresh start:</p>"},{"location":"notebooks/Satellite_data/#reprojecting-into-original-high-resolution-spatial-grid","title":"Reprojecting into original high-resolution spatial grid\u00b6","text":"<p>By setting <code>resample=True</code>, we can use interpolation to re-project our low resolution tide data back into the resolution of our satellite image, resulting in an individual tide height for every pixel in our dataset through time and space:</p>"},{"location":"notebooks/Satellite_data/#calculating-tide-height-minmaxmedianquantiles-for-each-pixel","title":"Calculating tide height min/max/median/quantiles for each pixel\u00b6","text":"<p>Min, max or any specific quantile of all tide heights observed over a region can be calculated for each pixel by passing in a list of quantiles/percentiles using the <code>calculate_quantiles</code> parameter.</p> <p>This calculation is performed on the low resolution modelled tide data before reprojecting to higher resolution, so should be faster than calculating min/max/median tide at high resolution:</p>"},{"location":"notebooks/Satellite_data/#modelling-custom-times","title":"Modelling custom times\u00b6","text":"<p>Instead of using times contained in the <code>time</code> dimension of our dataset, we can also calculate pixel-based tides for a custom set of times:</p>"},{"location":"notebooks/Satellite_data/#next-steps","title":"Next steps\u00b6","text":"<p>Now that we have learnt to combine tide modelling with satellite data, we can learn how to calculate statistics describing local tide dynamics, as well as biases caused by interactions between tidal processes and satellite orbits.</p>"},{"location":"notebooks/Tide_statistics/","title":"Calculating tide statistics and satellite biases","text":"In\u00a0[1]: Copied! <pre>directory = \"../../tests/data/tide_models/\"\n</pre> directory = \"../../tests/data/tide_models/\" In\u00a0[2]: Copied! <pre>import odc.stac\nimport pystac_client\nimport planetary_computer\n\n# Connect to STAC catalog\ncatalog = pystac_client.Client.open(\n    \"https://planetarycomputer.microsoft.com/api/stac/v1\",\n    modifier=planetary_computer.sign_inplace,\n)\n\n# Set cloud access defaults\nodc.stac.configure_rio(\n    cloud_defaults=True,\n    aws={\"aws_unsigned\": True},\n)\n\n# Build a query and search the STAC catalog for all matching items\nbbox = [122.160, -18.05, 122.260, -17.95]\nquery = catalog.search(\n    bbox=bbox,\n    collections=[\"sentinel-2-l2a\"],\n    datetime=\"2021/2023\",\n)\n\n# Load data into xarray format\nds_s2 = odc.stac.load(\n    items=list(query.items()),\n    bands=[\"red\"],\n    crs=\"utm\",\n    resolution=30,\n    groupby=\"solar_day\",\n    bbox=bbox,\n    fail_on_error=False,\n    chunks={},\n)\n\nprint(ds_s2)\n</pre> import odc.stac import pystac_client import planetary_computer  # Connect to STAC catalog catalog = pystac_client.Client.open(     \"https://planetarycomputer.microsoft.com/api/stac/v1\",     modifier=planetary_computer.sign_inplace, )  # Set cloud access defaults odc.stac.configure_rio(     cloud_defaults=True,     aws={\"aws_unsigned\": True}, )  # Build a query and search the STAC catalog for all matching items bbox = [122.160, -18.05, 122.260, -17.95] query = catalog.search(     bbox=bbox,     collections=[\"sentinel-2-l2a\"],     datetime=\"2021/2023\", )  # Load data into xarray format ds_s2 = odc.stac.load(     items=list(query.items()),     bands=[\"red\"],     crs=\"utm\",     resolution=30,     groupby=\"solar_day\",     bbox=bbox,     fail_on_error=False,     chunks={}, )  print(ds_s2) <pre>&lt;xarray.Dataset&gt; Size: 111MB\nDimensions:      (y: 371, x: 356, time: 211)\nCoordinates:\n  * y            (y) float64 3kB 8.015e+06 8.015e+06 ... 8.004e+06 8.004e+06\n  * x            (x) float64 3kB 4.11e+05 4.111e+05 ... 4.217e+05 4.217e+05\n    spatial_ref  int32 4B 32751\n  * time         (time) datetime64[ns] 2kB 2021-01-03T02:04:51.024000 ... 202...\nData variables:\n    red          (time, y, x) float32 111MB dask.array&lt;chunksize=(1, 371, 356), meta=np.ndarray&gt;\n</pre> In\u00a0[3]: Copied! <pre>from eo_tides.stats import tide_stats\n\nstatistics_df = tide_stats(\n    data=ds_s2,\n    directory=directory,\n)\n</pre> from eo_tides.stats import tide_stats  statistics_df = tide_stats(     data=ds_s2,     directory=directory, )  <pre>Using tide modelling location: 122.21, -18.00\nModelling tides with EOT20\nUsing tide modelling location: 122.21, -18.00\nModelling tides with EOT20\n\n\n\ud83c\udf0a Modelled astronomical tide range: 9.30 m (-4.60 to 4.70 m).\n\ud83d\udef0\ufe0f Observed tide range: 6.29 m (-2.36 to 3.93 m).\n\n\ud83d\udd34 68% of the modelled astronomical tide range was observed at this location.\n\ud83d\udfe2 The highest 8% (0.77 m) of the tide range was never observed.\n\ud83d\udd34 The lowest 24% (2.25 m) of the tide range was never observed.\n\n\ud83c\udf0a Mean modelled astronomical tide height: -0.00 m.\n\ud83d\udef0\ufe0f Mean observed tide height: 0.69 m.\n\u2b06\ufe0f The mean observed tide height was 0.69 m higher than the mean modelled astronomical tide height.\n</pre> <p>As we can see in the graph, Sentinel-2 captured a biased proportion of the tide range at this location: only observing ~68% of the tide range, and never observing the lowest 24% of tides.</p> <p>The <code>tide_stats</code> function also outputs a <code>pandas.Series</code> object containing statistics for the results above, including:</p> <ul> <li><code>mot</code>: mean tide height observed by the satellite (metres)</li> <li><code>mat</code>: mean modelled astronomical tide height (metres)</li> <li><code>hot</code>: maximum tide height observed by the satellite (metres)</li> <li><code>hat</code>: maximum tide height from modelled astronomical tidal range (metres)</li> <li><code>lot</code>: minimum tide height observed by the satellite (metres)</li> <li><code>lat</code>: minimum tide height from modelled astronomical tidal range (metres)</li> <li><code>otr</code>: tidal range observed by the satellite (metres)</li> <li><code>tr</code>: modelled astronomical tide range (metres)</li> <li><code>spread</code>: proportion of the full modelled tidal range observed by the satellite</li> <li><code>offset_low</code>: proportion of the lowest tides never observed by the satellite</li> <li><code>offset_high</code>: proportion of the highest tides never observed by the satellite</li> <li><code>y</code>: latitude used for modelling tide heights</li> <li><code>x</code>: longitude used for modelling tide heights</li> </ul> In\u00a0[4]: Copied! <pre>statistics_df\n</pre> statistics_df Out[4]: <pre>mot              0.691000\nmat             -0.000000\nhot              3.930000\nhat              4.696000\nlot             -2.355000\nlat             -4.604000\notr              6.285000\ntr               9.300000\nspread           0.676000\noffset_low       0.242000\noffset_high      0.082000\nx              122.209999\ny              -18.000000\ndtype: float32</pre> In\u00a0[5]: Copied! <pre># Build a query and search the STAC catalog for all matching items\nbbox = [122.160, -18.05, 122.260, -17.95]\nquery = catalog.search(\n    bbox=bbox,\n    collections=[\"sentinel-1-rtc\"],\n    datetime=\"2021/2023\",\n)\n\n# Load data into xarray format\nds_s1 = odc.stac.load(\n    items=list(query.items()),\n    bands=[\"vv\"],\n    crs=\"utm\",\n    resolution=30,\n    groupby=\"solar_day\",\n    bbox=bbox,\n    fail_on_error=False,\n    chunks={},\n)\n\nprint(ds_s1)\n</pre> # Build a query and search the STAC catalog for all matching items bbox = [122.160, -18.05, 122.260, -17.95] query = catalog.search(     bbox=bbox,     collections=[\"sentinel-1-rtc\"],     datetime=\"2021/2023\", )  # Load data into xarray format ds_s1 = odc.stac.load(     items=list(query.items()),     bands=[\"vv\"],     crs=\"utm\",     resolution=30,     groupby=\"solar_day\",     bbox=bbox,     fail_on_error=False,     chunks={}, )  print(ds_s1) <pre>&lt;xarray.Dataset&gt; Size: 47MB\nDimensions:      (y: 371, x: 356, time: 89)\nCoordinates:\n  * y            (y) float64 3kB 8.015e+06 8.015e+06 ... 8.004e+06 8.004e+06\n  * x            (x) float64 3kB 4.11e+05 4.111e+05 ... 4.217e+05 4.217e+05\n    spatial_ref  int32 4B 32751\n  * time         (time) datetime64[ns] 712B 2021-01-07T21:23:20.996123 ... 20...\nData variables:\n    vv           (time, y, x) float32 47MB dask.array&lt;chunksize=(1, 371, 356), meta=np.ndarray&gt;\n</pre> <p>When we run <code>tide_stats</code>, we can see a very different pattern: Sentinel-1 data is biased towards low tide observations, and never observes high tide at our location!</p> In\u00a0[6]: Copied! <pre>statistics_df = tide_stats(\n    data=ds_s1,\n    directory=directory,\n)\n</pre> statistics_df = tide_stats(     data=ds_s1,     directory=directory, )  <pre>Using tide modelling location: 122.21, -18.00\nModelling tides with EOT20\nUsing tide modelling location: 122.21, -18.00\nModelling tides with EOT20\n\n\n\ud83c\udf0a Modelled astronomical tide range: 9.55 m (-4.81 to 4.74 m).\n\ud83d\udef0\ufe0f Observed tide range: 6.40 m (-4.39 to 2.02 m).\n\n\ud83d\udd34 67% of the modelled astronomical tide range was observed at this location.\n\ud83d\udd34 The highest 28% (2.72 m) of the tide range was never observed.\n\ud83d\udfe2 The lowest 4% (0.43 m) of the tide range was never observed.\n\n\ud83c\udf0a Mean modelled astronomical tide height: -0.00 m.\n\ud83d\udef0\ufe0f Mean observed tide height: -1.31 m.\n\u2b07\ufe0f The mean observed tide height was -1.31 m lower than the mean modelled astronomical tide height.\n</pre> In\u00a0[7]: Copied! <pre>import xarray as xr\n\n# Give each observation a \"satellite_name\" based on its satellite\nds_s1 = ds_s1.assign_coords(satellite_name=(\"time\", [\"Sentinel-1\"] * ds_s1.sizes[\"time\"]))\nds_s2 = ds_s2.assign_coords(satellite_name=(\"time\", [\"Sentinel-2\"] * ds_s2.sizes[\"time\"]))\n\n# Combine both Sentinel-1 and Sentinel-2 data into a single dataset\nds_all = xr.concat([ds_s1, ds_s2], dim=\"time\")\nprint(ds_all)\n</pre> import xarray as xr  # Give each observation a \"satellite_name\" based on its satellite ds_s1 = ds_s1.assign_coords(satellite_name=(\"time\", [\"Sentinel-1\"] * ds_s1.sizes[\"time\"])) ds_s2 = ds_s2.assign_coords(satellite_name=(\"time\", [\"Sentinel-2\"] * ds_s2.sizes[\"time\"]))  # Combine both Sentinel-1 and Sentinel-2 data into a single dataset ds_all = xr.concat([ds_s1, ds_s2], dim=\"time\") print(ds_all) <pre>&lt;xarray.Dataset&gt; Size: 317MB\nDimensions:         (time: 300, y: 371, x: 356)\nCoordinates:\n  * y               (y) float64 3kB 8.015e+06 8.015e+06 ... 8.004e+06 8.004e+06\n  * x               (x) float64 3kB 4.11e+05 4.111e+05 ... 4.217e+05 4.217e+05\n    spatial_ref     int32 4B 32751\n  * time            (time) datetime64[ns] 2kB 2021-01-07T21:23:20.996123 ... ...\n    satellite_name  (time) &lt;U10 12kB 'Sentinel-1' 'Sentinel-1' ... 'Sentinel-2'\nData variables:\n    vv              (time, y, x) float32 158MB dask.array&lt;chunksize=(1, 371, 356), meta=np.ndarray&gt;\n    red             (time, y, x) float32 158MB dask.array&lt;chunksize=(1, 371, 356), meta=np.ndarray&gt;\n</pre> <p>We can now run <code>tide_stats</code> again. This time, we pass our satellite name coordinate to the function using the <code>plot_var=\"satellite_name\"</code> parameter. This will plot data from each of our satellites using a different symbol and colour.</p> In\u00a0[8]: Copied! <pre>statistics_df = tide_stats(\n    data=ds_all,\n    plot_var=\"satellite_name\",\n    directory=directory,\n)\n</pre> statistics_df = tide_stats(     data=ds_all,     plot_var=\"satellite_name\",     directory=directory, )  <pre>Using tide modelling location: 122.21, -18.00\nModelling tides with EOT20\nUsing tide modelling location: 122.21, -18.00\nModelling tides with EOT20\n\n\n\ud83c\udf0a Modelled astronomical tide range: 9.30 m (-4.60 to 4.70 m).\n\ud83d\udef0\ufe0f Observed tide range: 8.32 m (-4.39 to 3.93 m).\n\n\ud83d\udfe1 89% of the modelled astronomical tide range was observed at this location.\n\ud83d\udfe2 The highest 8% (0.77 m) of the tide range was never observed.\n\ud83d\udfe2 The lowest 2% (0.22 m) of the tide range was never observed.\n\n\ud83c\udf0a Mean modelled astronomical tide height: -0.00 m.\n\ud83d\udef0\ufe0f Mean observed tide height: 0.10 m.\n\u2b06\ufe0f The mean observed tide height was 0.10 m higher than the mean modelled astronomical tide height.\n</pre> <p>We can see that at this location, combining Sentinel-2 and Sentinel-1 data greatly improves our biases: our satellite data now covers ~89% of the modelled astronomical tide range, and only fails to observe 8% of the highest tides and 2% of the lowest tides!</p> In\u00a0[9]: Copied! <pre>from eo_tides.stats import pixel_stats\n\nstats_ds = pixel_stats(\n    data=ds_s2,\n    directory=directory,\n)\nprint(stats_ds)\n</pre> from eo_tides.stats import pixel_stats  stats_ds = pixel_stats(     data=ds_s2,     directory=directory, ) print(stats_ds) <pre>Creating reduced resolution 5000 x 5000 metre tide modelling array\nModelling tides with EOT20\nReturning low resolution tide array\nCreating reduced resolution 5000 x 5000 metre tide modelling array\nModelling tides with EOT20\nReturning low resolution tide array\n</pre> <pre>/workspaces/eo-tides/.venv/lib/python3.12/site-packages/numpy/lib/_nanfunctions_impl.py:1634: RuntimeWarning: All-NaN slice encountered\n  return fnb._ureduce(a,\n</pre> <pre>Reprojecting statistics into original resolution\n</pre> <pre>/workspaces/eo-tides/.venv/lib/python3.12/site-packages/rasterio/warp.py:387: NotGeoreferencedWarning: Dataset has no geotransform, gcps, or rpcs. The identity matrix will be returned.\n  dest = _reproject(\n</pre> <pre>&lt;xarray.Dataset&gt; Size: 6MB\nDimensions:      (y: 371, x: 356)\nCoordinates:\n    tide_model   &lt;U5 20B 'EOT20'\n  * y            (y) float64 3kB 8.015e+06 8.015e+06 ... 8.004e+06 8.004e+06\n  * x            (x) float64 3kB 4.11e+05 4.111e+05 ... 4.217e+05 4.217e+05\n    spatial_ref  int32 4B 32751\nData variables:\n    mot          (y, x) float32 528kB 0.7088 0.7088 0.7088 ... 0.6832 0.6832\n    mat          (y, x) float32 528kB -0.0001353 -0.0001353 ... -0.0001289\n    hot          (y, x) float32 528kB 3.874 3.874 3.874 ... 3.948 3.948 3.948\n    hat          (y, x) float32 528kB 4.494 4.494 4.494 ... 4.773 4.773 4.773\n    lot          (y, x) float32 528kB -2.236 -2.236 -2.236 ... -2.402 -2.402\n    lat          (y, x) float32 528kB -4.425 -4.425 -4.425 ... -4.672 -4.673\n    otr          (y, x) float32 528kB 6.109 6.109 6.109 6.109 ... 6.35 6.35 6.35\n    tr           (y, x) float32 528kB 8.919 8.919 8.919 ... 9.445 9.445 9.446\n    spread       (y, x) float32 528kB 0.685 0.685 0.685 ... 0.6723 0.6723 0.6723\n    offset_low   (y, x) float32 528kB 0.2455 0.2455 0.2455 ... 0.2403 0.2403\n    offset_high  (y, x) float32 528kB 0.0695 0.0695 0.0695 ... 0.08738 0.0874\n</pre> <p>We can explore these statistics on a map:</p> In\u00a0[10]: Copied! <pre>stats_ds.spread.odc.explore()\n</pre> stats_ds.spread.odc.explore() Out[10]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook <p>Or plot them directly:</p> In\u00a0[11]: Copied! <pre>import matplotlib.pyplot as plt\n\nfig, axes = plt.subplots(1, 3, figsize=(16, 4))\nstats_ds.spread.plot(ax=axes[0], vmin=0.5, vmax=0.9, cmap=\"magma_r\", add_labels=False)\nstats_ds.offset_low.plot(ax=axes[1], vmin=0, vmax=0.35, cmap=\"magma\", add_labels=False)\nstats_ds.offset_high.plot(ax=axes[2], vmin=0, vmax=0.35, cmap=\"magma\", add_labels=False)\naxes[0].set_title(\"Spread\")\naxes[1].set_title(\"Low tide offset\")\naxes[2].set_title(\"High tide offset\");\n</pre> import matplotlib.pyplot as plt  fig, axes = plt.subplots(1, 3, figsize=(16, 4)) stats_ds.spread.plot(ax=axes[0], vmin=0.5, vmax=0.9, cmap=\"magma_r\", add_labels=False) stats_ds.offset_low.plot(ax=axes[1], vmin=0, vmax=0.35, cmap=\"magma\", add_labels=False) stats_ds.offset_high.plot(ax=axes[2], vmin=0, vmax=0.35, cmap=\"magma\", add_labels=False) axes[0].set_title(\"Spread\") axes[1].set_title(\"Low tide offset\") axes[2].set_title(\"High tide offset\");"},{"location":"notebooks/Tide_statistics/#calculating-tide-statistics-and-satellite-biases","title":"Calculating tide statistics and satellite biases\u00b6","text":"<p>This guide demonstrates how to use the <code>tide_stats</code> and  <code>pixel_stats</code> functions from <code>eo_tides.stats</code> to calculate local tide statistics and identify biases caused by interactions between tidal processes and satellite orbits.</p> <p>Complex tide aliasing interactions between temporal tide dynamics and the regular overpass timing of sun-synchronous satellite sensors mean that satellites often do not always observe the entire tidal cycle. Biases in satellite coverage of the tidal cycle can mean that tidal extremes (e.g. the lowest or highest tides at a location) or particular tidal processes may either never be captured by satellites, or be over-represented in the satellite record. Local tide dynamics can cause these biases to vary greatly both through time and space, making it challenging to compare coastal processes consistently - particularly for large-scale coastal EO analyses.</p> <p>To ensure that coastal EO analyses are not inadvertently affected by tide biases, it is important to compare how well the tides observed by satellites match the full range of tides at a location. The <code>tidal_stats</code> and <code>pixel_stats</code> functions compares the subset of tides observed by satellite data against the full range of tides modelled at a regular interval through time (every two hours by default) across the entire time period covered by the satellite dataset. This comparison is used to calculate several useful statistics and plots that summarise how well your satellite data capture real-world tidal conditions.</p> <p>Figure 1: Example of tide biases in Landsat satellite data across coastal Australia (Bishop-Taylor et al. 2018). \"Spread\" represents the proportion of the astronomical tide range observed by satellites; low and high tide \"offsets\" represent the proportion of highest and lowest tides never observed.</p> <p>Tip</p> <p>         For a more detailed discussion of the issue of tidal bias in sun-synchronous satellite observations of the coastline, refer to the 'Limitations and future work' section in Bishop-Taylor et al. 2018. </p>"},{"location":"notebooks/Tide_statistics/#getting-started","title":"Getting started\u00b6","text":"<p>As in the previous examples, our first step is to tell <code>eo-tides</code> the location of our tide model or clipped tide model directory (if you haven't set this up, refer to the setup instructions here):</p>"},{"location":"notebooks/Tide_statistics/#load-sentinel-2-satellite-data-using-odc-stac","title":"Load Sentinel-2 satellite data using odc-stac\u00b6","text":"<p>We can now load a time-series of satellite data over our area of interest using the Open Data Cube's <code>odc-stac</code> package. In this example, we will load Sentinel-2 satellite data from 2021-2023 over the city of Broome, Western Australia. We will load this data from the Microsoft Planetary Computer STAC catalogue.</p> <p>Tip</p> <p>         For a more detailed guide to using STAC metadata and <code>odc-stac</code> to find and load satellite data, refer to the STAC user guide here.     </p>"},{"location":"notebooks/Tide_statistics/#using-tide_stats","title":"Using tide_stats\u00b6","text":"<p>Once we have loaded some satellite data, we can pass this to the <code>tide_stats</code> function to calculate local tide statistics and reveal any potential tidal biases. The <code>tide_stats</code> function will return a plain-text summary below, as well as a visual plot that compares the distribution of satellite-observed tides (black dots) against the full range of modelled astronomical tide conditions (blue) using three useful metrics:</p> <ol> <li>Spread: The proportion of the full modelled astronomical tidal range that was observed by satellites. A high value indicating good coverage of the tide range.</li> <li>High tide offset: The proportion of the highest tides not observed by satellites at any time, as a proportion of the full modelled astronomical tidal range. A high value indicates that the satellite data is biased towards never capturing high tides.</li> <li>Low tide offset: The proportion of the lowest tides not observed by satellites at any time, as a proportion of the full modelled astronomical tidal range. A high value indicates that the satellite data is biased towards never capturing low tides.</li> </ol> <p>Tip</p> <p>         For a more detailed description of these biases, see Bishop-Taylor et al. 2018. </p>"},{"location":"notebooks/Tide_statistics/#compare-against-sentinel-1-tide-biases","title":"Compare against Sentinel-1 tide biases\u00b6","text":"<p>In the previous example, we saw that Sentinel-2 data was biased towards never capturing low tide at our location. These biases are caused by the consistent 10:30 am local overpass time of the Sentinel-2 satellites, which due to a phenomenon called \"tide-aliasing\" means that certain tides never occur when the satellite overpasses.</p> <p>One possible way around these biases is to use different satellite data from satellites that overpass at different times. For example, Sentinel-1 radar satellites follow a different orbit to Sentinel-2, overpassing at a local time of 6:00 pm instead of 10:30 am. This diference in overpass time potentially means that Sentinel-1 satellite data may capture different tides to Sentinel-2.</p> <p>In the next example, we run the <code>tide_stats</code> function on data loaded from Sentinel-1 for the same location and time period to see if this data is affected by the same tide biases.</p>"},{"location":"notebooks/Tide_statistics/#calculate-biases-for-multiple-satellite-sensors","title":"Calculate biases for multiple satellite sensors\u00b6","text":"<p>At our location, Sentinel-2 optical satellites are biased towards high tide observations, while Sentinel-1 radar satellites are biased towards low tide observations. Could combining data from multiple EO sensors help us capture a more complete view of tides at this location?</p> <p>To test this theory, we can combine Sentinel-2 and Sentinel-1 data into a single <code>xarray.Dataset</code>, recording the name of each sensor using a new <code>satellite_name</code> coordinate in our data:</p>"},{"location":"notebooks/Tide_statistics/#using-pixel_stats","title":"Using pixel_stats\u00b6","text":""},{"location":"notebooks/Tide_statistics/#modelling-tide-statistics-and-biases-spatially","title":"Modelling tide statistics and biases spatially\u00b6","text":"<p>Because tide regimes and satellite biases can vary greatly along the coast, it can be useful to plot these biases spatially. To do this, we can use the <code>pixel_stats</code> function.</p> <p><code>pixel_stats</code> works similarly to <code>tide_stats</code>, except that statistics are calculated across the entire extent of your satellite dataset. The function will generate an <code>xarray.Dataset</code> output containing the statistics discussed above as two-dimensional arrays.</p> <p>Tip</p> <p>         The <code>pixel_stats</code> function uses <code>eo_tides.eo.pixel_tides</code> to model tides spatially. You can experiment passing in parameters like <code>resolution</code> and <code>buffer</code> to customise the modelling grid used for calculating tide biases. Be warned however that you can quickly run out of memory with large analyses, given the number of timesteps required to model astronomical low and high tide.     </p>"},{"location":"notebooks/Tide_statistics/#next-steps","title":"Next steps\u00b6","text":"<p>We have explored calculating tide statistics and biases in EO data. Now we can learn how to validate modelled tides against measured tide gauge data to ensure the tides we are modelling are accurate.</p>"},{"location":"notebooks/Validating_tides/","title":"Validating modelled tide heights","text":"In\u00a0[1]: Copied! <pre>directory = \"../../tests/data/tide_models/\"\n</pre> directory = \"../../tests/data/tide_models/\" In\u00a0[2]: Copied! <pre>from eo_tides.model import model_tides\nimport pandas as pd\n\nx, y = 122.2186, -18.0008\nstart_time = \"2018-01-01\"\nend_time = \"2018-01-31\"\n\nmodelled_df = model_tides(\n    x=x,\n    y=y,\n    time=pd.date_range(start=start_time, end=end_time, freq=\"1h\"),\n    directory=directory,\n)\n\n# Print outputs\nmodelled_df.head()\n</pre> from eo_tides.model import model_tides import pandas as pd  x, y = 122.2186, -18.0008 start_time = \"2018-01-01\" end_time = \"2018-01-31\"  modelled_df = model_tides(     x=x,     y=y,     time=pd.date_range(start=start_time, end=end_time, freq=\"1h\"),     directory=directory, )  # Print outputs modelled_df.head() <pre>Modelling tides using EOT20\n</pre> Out[2]: tide_model tide_height time x y 2018-01-01 00:00:00 122.2186 -18.0008 EOT20 1.229286 2018-01-01 01:00:00 122.2186 -18.0008 EOT20 2.162897 2018-01-01 02:00:00 122.2186 -18.0008 EOT20 2.476600 2018-01-01 03:00:00 122.2186 -18.0008 EOT20 2.112390 2018-01-01 04:00:00 122.2186 -18.0008 EOT20 1.181283 In\u00a0[3]: Copied! <pre>gesla_data_path = \"../../tests/data/\"\ngesla_metadata_path = \"../../tests/data/GESLA3_ALL 2.csv\"\n</pre> gesla_data_path = \"../../tests/data/\" gesla_metadata_path = \"../../tests/data/GESLA3_ALL 2.csv\" <p>To load GESLA measured sea-level data for our location, we can pass in the same <code>x</code> and <code>y</code> location and time period that we used to originally model our tides. This will ensure that we load only the gauge data we actually need.</p> <p>Tip</p> <p>         The <code>load_gauge_gesla</code> function will automatically identify the nearest GESLA tide gauge to an <code>x</code>, <code>y</code> coordinate; pass a set of bounding box tuples (e.g. <code>x=(120, 130), y=(-20, -30)</code> to return all tide gauges within a bounding box instead.     </p> In\u00a0[4]: Copied! <pre>from eo_tides.validation import load_gauge_gesla\n\n# Load gauge data\ngauge_df = load_gauge_gesla(\n    x=x,\n    y=y,\n    time=(start_time, end_time),\n    correct_mean=True,\n    data_path=gesla_data_path,\n    metadata_path=gesla_metadata_path,\n)\ngauge_df.head()\n</pre> from eo_tides.validation import load_gauge_gesla  # Load gauge data gauge_df = load_gauge_gesla(     x=x,     y=y,     time=(start_time, end_time),     correct_mean=True,     data_path=gesla_data_path,     metadata_path=gesla_metadata_path, ) gauge_df.head() Out[4]: sea_level qc_flag use_flag file_name site_name country contributor_abbreviated contributor_full contributor_website contributor_contact ... start_date_time end_date_time number_of_years time_zone_hours datum_information instrument precision null_value gauge_type overall_record_quality site_code time 62650 2018-01-01 00:00:00 1.208329 1 1 ../../tests/data/broome-62650-aus-bom Broome AUS BOM Bureau of Meteorology http://www.bom.gov.au/oceanography/projects/nt... tides@bom.gov.au ... 2/07/1966 0:00 31/12/2019 23:00 51 0 Chart Datum / Lowest Astronomical Tide Unspecified Unspecified -99.9999 Coastal No obvious issues 2018-01-01 01:00:00 2.311329 1 1 ../../tests/data/broome-62650-aus-bom Broome AUS BOM Bureau of Meteorology http://www.bom.gov.au/oceanography/projects/nt... tides@bom.gov.au ... 2/07/1966 0:00 31/12/2019 23:00 51 0 Chart Datum / Lowest Astronomical Tide Unspecified Unspecified -99.9999 Coastal No obvious issues 2018-01-01 02:00:00 2.712329 1 1 ../../tests/data/broome-62650-aus-bom Broome AUS BOM Bureau of Meteorology http://www.bom.gov.au/oceanography/projects/nt... tides@bom.gov.au ... 2/07/1966 0:00 31/12/2019 23:00 51 0 Chart Datum / Lowest Astronomical Tide Unspecified Unspecified -99.9999 Coastal No obvious issues 2018-01-01 03:00:00 2.137329 1 1 ../../tests/data/broome-62650-aus-bom Broome AUS BOM Bureau of Meteorology http://www.bom.gov.au/oceanography/projects/nt... tides@bom.gov.au ... 2/07/1966 0:00 31/12/2019 23:00 51 0 Chart Datum / Lowest Astronomical Tide Unspecified Unspecified -99.9999 Coastal No obvious issues 2018-01-01 04:00:00 1.049329 1 1 ../../tests/data/broome-62650-aus-bom Broome AUS BOM Bureau of Meteorology http://www.bom.gov.au/oceanography/projects/nt... tides@bom.gov.au ... 2/07/1966 0:00 31/12/2019 23:00 51 0 Chart Datum / Lowest Astronomical Tide Unspecified Unspecified -99.9999 Coastal No obvious issues <p>5 rows \u00d7 26 columns</p> <p>We have successfully loaded data for the Broome tide gauge (GESLA site code 62650)! We can now plot sea levels over time - note that the gauge dataset is missing some data in late January 2018:</p> In\u00a0[5]: Copied! <pre>gauge_df.droplevel(\"site_code\").sea_level.plot()\n</pre> gauge_df.droplevel(\"site_code\").sea_level.plot() Out[5]: <pre>&lt;Axes: xlabel='time'&gt;</pre> In\u00a0[6]: Copied! <pre>import matplotlib.pyplot as plt\n\n# Join our modelled data to the timesteps in our gauge data\njoined_df = gauge_df.join(modelled_df).dropna()\n\n# Plot as a scatterplot with 1:1 line\nax = joined_df.plot.scatter(x=\"sea_level\", y=\"tide_height\")\nplt.plot([-5, 5], [-5, 5], c=\"red\", linestyle=\"dashed\")\nax.set_aspect(1.0)\nax.set_ylabel(\"Modelled tide (m)\")\nax.set_xlabel(\"GESLA sea level (m)\");\n</pre> import matplotlib.pyplot as plt  # Join our modelled data to the timesteps in our gauge data joined_df = gauge_df.join(modelled_df).dropna()  # Plot as a scatterplot with 1:1 line ax = joined_df.plot.scatter(x=\"sea_level\", y=\"tide_height\") plt.plot([-5, 5], [-5, 5], c=\"red\", linestyle=\"dashed\") ax.set_aspect(1.0) ax.set_ylabel(\"Modelled tide (m)\") ax.set_xlabel(\"GESLA sea level (m)\"); <p>We can see that both datasets are highly correlated. To quantify this, we can use the <code>eo_tides.validation.eval_metrics</code> function to compare them and calculate some useful accuracy statistics, including Root Mean Square Error (RMSE), Mean Absolute Error (MAE), R-squared and bias.</p> <p>Our results show that our modelled tides closely reproduced observed sea levels at this location:</p> In\u00a0[7]: Copied! <pre>from eo_tides.validation import eval_metrics\n\n# Calculate accuracy metrics\naccuracy_metrics = eval_metrics(x=joined_df.sea_level, y=joined_df.tide_height)\naccuracy_metrics\n</pre> from eo_tides.validation import eval_metrics  # Calculate accuracy metrics accuracy_metrics = eval_metrics(x=joined_df.sea_level, y=joined_df.tide_height) accuracy_metrics Out[7]: <pre>Correlation         0.997\nRMSE                0.159\nMAE                 0.126\nR-squared           0.994\nBias               -0.005\nRegression slope    0.979\ndtype: float64</pre> In\u00a0[8]: Copied! <pre>models = [\"EOT20\", \"GOT5.5\", \"HAMTIDE11\"]\n\nmodelled_df = model_tides(\n    x=x,\n    y=y,\n    time=pd.date_range(start=start_time, end=end_time, freq=\"1h\"),\n    model=models,\n    output_format=\"wide\",\n    directory=directory,\n)\nmodelled_df.head()\n</pre> models = [\"EOT20\", \"GOT5.5\", \"HAMTIDE11\"]  modelled_df = model_tides(     x=x,     y=y,     time=pd.date_range(start=start_time, end=end_time, freq=\"1h\"),     model=models,     output_format=\"wide\",     directory=directory, ) modelled_df.head() <pre>Modelling tides using EOT20, GOT5.5, HAMTIDE11 in parallel\n</pre> <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3/3 [00:00&lt;00:00, 25.57it/s]\n</pre> <pre>Converting to a wide format dataframe\n</pre> Out[8]: tide_model EOT20 GOT5.5 HAMTIDE11 time x y 2018-01-01 00:00:00 122.2186 -18.0008 1.229286 1.292904 1.422702 2018-01-01 01:00:00 122.2186 -18.0008 2.162897 2.290366 2.302042 2018-01-01 02:00:00 122.2186 -18.0008 2.476600 2.629404 2.537032 2018-01-01 03:00:00 122.2186 -18.0008 2.112390 2.244390 2.072846 2018-01-01 04:00:00 122.2186 -18.0008 1.181283 1.258280 1.034931 <p>We can now merge these modelled tides with our measured gauge data:</p> In\u00a0[9]: Copied! <pre># Join our modelled data to the timesteps in our gauge data\njoined_df = gauge_df.join(modelled_df).dropna()\n\n# Plot measured sea levels and modelled data\njoined_df.droplevel([\"site_code\", \"x\", \"y\"])[[\"sea_level\"] + models].plot()\n</pre> # Join our modelled data to the timesteps in our gauge data joined_df = gauge_df.join(modelled_df).dropna()  # Plot measured sea levels and modelled data joined_df.droplevel([\"site_code\", \"x\", \"y\"])[[\"sea_level\"] + models].plot() Out[9]: <pre>&lt;Axes: xlabel='time'&gt;</pre> <p>Now, we can loop through each of our models and calculate accuracy metrics compared to our gauge data for each of them:</p> In\u00a0[10]: Copied! <pre># Calculate accuracy metrics for each model\naccuracy_dict = {}\nfor model in models:\n    accuracy_dict[model] = eval_metrics(x=joined_df.sea_level, y=joined_df[model])\n\n# Merge into a single dataframe\ncombined_accuracy_df = pd.DataFrame.from_dict(accuracy_dict)\ncombined_accuracy_df\n</pre> # Calculate accuracy metrics for each model accuracy_dict = {} for model in models:     accuracy_dict[model] = eval_metrics(x=joined_df.sea_level, y=joined_df[model])  # Merge into a single dataframe combined_accuracy_df = pd.DataFrame.from_dict(accuracy_dict) combined_accuracy_df Out[10]: EOT20 GOT5.5 HAMTIDE11 Correlation 0.997 0.997 0.993 RMSE 0.159 0.152 0.239 MAE 0.126 0.118 0.193 R-squared 0.994 0.994 0.986 Bias -0.005 -0.010 -0.011 Regression slope 0.979 0.996 0.963 <p>As we can see above, at this location <code>GOT5.5</code> has the best overall accuracy as measured by RMSE and MAE, while results from <code>HAMTIDE11</code> are less accurate and slightly less correlated with our measured gauge data.</p>"},{"location":"notebooks/Validating_tides/#validating-modelled-tide-heights","title":"Validating modelled tide heights\u00b6","text":"<p>This guide demonstrates how to use the <code>load_gauge_gesla</code> function from <code>eo_tides.stats</code> to validate modelled tides from <code>eo-tides</code> using tide gauge data.</p> <p>The tide models used by <code>eo-tides</code> can vary significantly in accuracy across the world's coastlines. Evaluating the accuracy of your modelled tides is critical for ensuring that resulting marine or coastal EO analyses are reliable and useful.</p> <p>The <code>load_gauge_gesla</code> function provides a convenient tool for loading high-quality sea-level measurements from the GESLA Global Extreme Sea Level Analysis archive \u2013 a global archive of almost 90,713 years of sea level data from 5,119 records across the world. This data can be used to compare against tides modelled using <code>eo-tides</code> to calculate the accuracy of your tide modelling and identify the optimal tide models to use for your study area.</p>"},{"location":"notebooks/Validating_tides/#getting-started","title":"Getting started\u00b6","text":"<p>As in the previous examples, our first step is to tell <code>eo-tides</code> the location of our tide model directory (if you haven't set this up, refer to the setup instructions here):</p>"},{"location":"notebooks/Validating_tides/#example-modelled-tides","title":"Example modelled tides\u00b6","text":"<p>First, we can model hourly tides for a location (Broome, Western Australia) and time period (January 2018) of interest using the <code>eo_tides.model.model_tides</code> function:</p>"},{"location":"notebooks/Validating_tides/#loading-gesla-tide-gauge-data","title":"Loading GESLA tide gauge data\u00b6","text":"<p>To evaluate the accuracy of these modelled tides, we can load measured sea-level data from the nearest GESLA tide gauge using <code>load_gauge_gesla</code>.</p> <p>To obtain GESLA data, you will need to download both \"GESLA-3 data\" and \"GESLA-3 CSV META-DATA FILE\" from the Downloads page of the GESLA website, and save these to a convenient location.</p> <p>We have provided an example below; replace these paths to point to your downloaded data.</p>"},{"location":"notebooks/Validating_tides/#validation-against-gesla-tide-gauges","title":"Validation against GESLA tide gauges\u00b6","text":"<p>Now we have modelled some tides and loaded some measured sea-level data, we can compare them. Note that because the timeseries above is missing some data in late January, we need to \"join\" our modelled <code>modelled_df</code> data to the timesteps present in <code>gauge_df</code>.</p> <p>Now let's generate a scatterplot with our measured data on the x-axis, and our modelled tides on the y-axis:</p>"},{"location":"notebooks/Validating_tides/#identifying-best-local-tide-models","title":"Identifying best local tide models\u00b6","text":"<p>Because different ocean tide models can perform better or worse in different locations, it can be valuable to compare the accuracy of different models against measured gauge data. This can help us make an informed decision about the best model to use for a given application or study area.</p> <p>In the example below, we will use <code>model_tides</code> to model tides using three different models: <code>EOT20</code>, <code>GOT5.5</code>, and <code>HAMTIDE11</code>:</p>"}]}